<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üóÉÔ∏è</text></svg>">
    <title>Taboolingo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap');

        :root {
            --bg-color: #f8fafc;
            /* Slate-50 */
            --primary-color: #4f46e5;
            /* Indigo-600 (French UI) */
            --secondary-color: #64748b;
            /* Slate-500 */
            --primary-light: #e0e7ff;
            /* Indigo-100 */
            --text-color: #1e293b;

            /* Permanent Team Colors */
            --team-a: #d946ef;
            /* Fuchsia-500 */
            --team-a-light: #fdf4ff;
            /* Fuchsia-50 */
            --team-b: #0ea5e9;
            /* Sky-500 */
            --team-b-light: #f0f9ff;
            /* Sky-50 */
        }

        .theme-english {
            --bg-color: #fafaf9;
            /* Stone-50 */
            --primary-color: #e11d48;
            /* Rose-600 (English UI) */
            --secondary-color: #78716c;
            /* Stone-500 */
            --primary-light: #ffe4e6;
            /* Rose-100 */
        }

        /* Semantic Utilities */
        .text-primary {
            color: var(--primary-color) !important;
        }

        .bg-primary {
            background-color: var(--primary-color) !important;
        }

        .bg-primary-light {
            background-color: var(--primary-light) !important;
        }

        .border-primary {
            border-color: var(--primary-color) !important;
        }

        .text-team-a {
            color: var(--team-a) !important;
        }

        .bg-team-a {
            background-color: var(--team-a) !important;
        }

        .bg-team-a-light {
            background-color: var(--team-a-light) !important;
        }

        .border-team-a {
            border-color: var(--team-a) !important;
        }

        .text-team-b {
            color: var(--team-b) !important;
        }

        .bg-team-b {
            background-color: var(--team-b) !important;
        }

        .bg-team-b-light {
            background-color: var(--team-b-light) !important;
        }

        .border-team-b {
            border-color: var(--team-b) !important;
        }

        /* Legacy Override Cleanup */
        body.theme-english .text-pink-500,
        body.theme-english .bg-pink-500,
        body.theme-english .bg-pink-50,
        body.theme-english .border-pink-500,
        body.theme-english .text-pink-600 {
            /* No longer needed with semantic vars, but keeping empty to override if I missed some */
        }

        body {
            font-family: 'Lexend', sans-serif;
            background-color: var(--pastel-bg);
            touch-action: manipulation;
            overflow-x: hidden;
            min-height: 100dvh;
        }

        .btn-3d {
            transition: all 0.1s ease-in-out;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.1);
        }

        .btn-3d:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.1);
        }

        .btn-3d:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .buzzer-button {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            border-radius: 50%;
            border: 6px solid #660000;
            box-shadow: 0 10px 0 0 #4d0000, 0 15px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.05s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 1rem;
            user-select: none;
            margin: 0 auto;
        }

        .buzzer-button:active {
            transform: translateY(6px);
            box-shadow: 0 4px 0 0 #4d0000, 0 8px 8px rgba(0, 0, 0, 0.2);
        }

        .level-btn {
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .level-btn.selected {
            border-color: var(--primary-color);
            transform: scale(1.05);
            background-color: var(--primary-light);
        }

        .overlay {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
        }

        .pulse-timer {
            animation: pulse 1s infinite !important;
            color: #ef4444 !important;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .buzz-flash {
            animation: flashRed 0.3s ease-out;
        }

        @keyframes flashRed {
            0% {
                background-color: transparent;
            }

            50% {
                background-color: rgba(239, 68, 68, 0.3);
            }

            100% {
                background-color: transparent;
            }
        }

        .word-link {
            text-decoration: none;
            transition: color 0.2s;
        }

        .word-link:hover {
            color: #ec4899;
            text-decoration: underline;
        }

        #word-review-list {
            max-height: 50vh;
            overflow-y: auto;
        }

        .player-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .room-code-display {
            font-family: 'Courier New', monospace;
            letter-spacing: 0.2em;
        }

        .team-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
        }

        .team-a {
            background-color: var(--team-a-light);
            color: var(--team-a);
        }

        .team-b {
            background-color: var(--team-b-light);
            color: var(--team-b);
        }

        .team-score-card {
            padding: 12px;
            border-radius: 16px;
            text-align: center;
            flex: 1;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .team-winner-glow {
            box-shadow: 0 0 20px rgba(217, 70, 239, 0.3);
            border: 2px solid var(--team-a);
        }

        .team-winner-glow-b {
            box-shadow: 0 0 20px rgba(14, 165, 233, 0.3);
            border: 2px solid var(--team-b);
        }

        /* Team Themes for Game Board */
        .team-a-theme {
            border-color: var(--team-a) !important;
        }

        .team-b-theme {
            border-color: var(--team-b) !important;
        }

        .your-team-pill {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 60;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .role-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 4px;
            animation: pulse-role 2s infinite;
        }

        @keyframes pulse-role {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .winner-animation {
            animation: celebrate 1s ease-in-out infinite;
        }

        @keyframes celebrate {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
            }

            25% {
                transform: scale(1.1) rotate(-5deg);
            }

            75% {
                transform: scale(1.1) rotate(5deg);
            }
        }

        .loser-animation {
            animation: console 2s ease-in-out;
            opacity: 0.7;
        }

        @keyframes console {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0);
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #ec4899;
            position: absolute;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>

<body id="main-body" class="flex flex-col items-center justify-start p-4 pt-20 transition-colors min-h-screen">

    <!-- Persistent Team Badge -->
    <div id="your-team-badge" class="hidden your-team-pill"></div>

    <!-- HUD -->
    <div id="game-hud"
        class="fixed top-0 left-0 w-full p-2 flex justify-center items-center z-50 opacity-0 transition-opacity pointer-events-none">
        <div
            class="bg-white/80 backdrop-blur-md px-4 py-2 rounded-2xl shadow-lg border border-slate-200 pointer-events-auto flex items-center gap-4 max-w-full overflow-x-auto no-scrollbar">

            <!-- Leave Button -->
            <button id="leave-game-btn" onclick="game.showLeaveGameModal()"
                class="hidden bg-slate-100 hover:bg-slate-200 text-slate-600 px-3 py-1.5 rounded-xl text-[10px] font-black uppercase transition-colors">
                Leave
            </button>

            <div class="h-4 w-[1px] bg-slate-200 hidden" id="leave-separator"></div>

            <!-- Score -->
            <div class="flex flex-col items-center min-w-[40px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Score</span>
                <div id="score-display" class="text-lg font-black text-primary leading-none">0</div>
            </div>

            <!-- Timer -->
            <div id="timer-box"
                class="flex flex-col items-center bg-slate-50 px-3 py-1 rounded-xl border border-slate-100 min-w-[50px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Time</span>
                <div id="timer-display" class="text-xl font-black text-slate-700 leading-none">60</div>
            </div>

            <!-- Stack -->
            <div id="stack-box" class="flex flex-col items-center min-w-[40px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Stack</span>
                <div id="stack-display" class="text-lg font-black text-slate-700 leading-none">0</div>
            </div>

            <div class="h-4 w-[1px] bg-slate-200"></div>

            <!-- Connection Status -->
            <div id="connection-status" class="flex items-center gap-1.5">
                <span id="connection-dot" class="w-2.5 h-2.5 rounded-full bg-slate-300 shadow-inner"></span>
                <span id="connection-text" class="text-[10px] font-black text-slate-500 uppercase">Offline</span>
            </div>
        </div>
    </div>

    <main class="w-full max-w-md my-auto">
        <!-- START SCREEN -->
        <div id="screen-start" class="text-center">
            <div id="main-logo-emoji" class="text-6xl mb-4">üá´üá∑</div>
            <h1 class="text-3xl font-black text-slate-800 mb-2">Taboo<span class="text-primary">lingo</span></h1>
            <p id="total-card-count" class="text-[10px] font-black text-primary uppercase mb-4 tracking-widest">
                Loading...</p>

            <!-- Mode Tabs (Step 1) -->
            <div class="text-[10px] font-black text-slate-400 uppercase mb-2 tracking-widest text-center">1. Connection
                Mode</div>
            <div class="flex bg-slate-100 p-1 rounded-2xl mb-6 shadow-inner">
                <button id="tab-local" onclick="game.setTab('local')"
                    class="flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 bg-white text-slate-800 shadow-sm">
                    <span>üì±</span> Local
                </button>
                <button id="tab-online" onclick="game.setTab('online')"
                    class="flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 text-slate-400">
                    <span>üåê</span> Online
                </button>
            </div>

            <!-- Tab Content: Local -->
            <div id="content-local" class="space-y-6">
                <!-- Language Selection (Step 2) -->
                <div class="mb-6">
                    <div class="text-[10px] font-black text-slate-400 uppercase mb-2 tracking-widest text-center">2.
                        Select
                        Language</div>
                    <div class="flex gap-4">
                        <button id="lang-fr" onclick="game.setLanguage('fr')"
                            class="flex-1 py-4 rounded-2xl bg-white border-4 border-slate-100 shadow-sm transition-all hover:scale-105 active:scale-95 group">
                            <div class="text-4xl mb-1 group-hover:scale-110 transition-transform"><span
                                    class="emoji-fr">üá´üá∑</span></div>
                            <div
                                class="text-xs font-black text-slate-400 uppercase tracking-wider group-[.selected]:text-primary">
                                Fran√ßais</div>
                        </button>
                        <button id="lang-en" onclick="game.setLanguage('en')"
                            class="flex-1 py-4 rounded-2xl bg-white border-4 border-slate-100 shadow-sm transition-all hover:scale-105 active:scale-95 group">
                            <div class="text-4xl mb-1 group-hover:scale-110 transition-transform"><span
                                    class="emoji-en">üá¨üáß</span></div>
                            <div
                                class="text-xs font-black text-slate-400 uppercase tracking-wider group-[.selected]:text-primary">
                                English</div>
                        </button>
                    </div>
                </div>
                <!-- Level Selection -->
                <!-- Level Selection (Step 3) -->
                <div>
                    <div class="text-[10px] font-black text-slate-400 uppercase mb-2 tracking-widest text-center">3.
                        Select
                        Difficulty</div>
                    <div class="grid grid-cols-2 gap-3">
                        <button
                            class="level-btn p-4 rounded-2xl bg-white border-2 border-slate-100 transition-all text-left opacity-50 cursor-not-allowed"
                            onclick="game.setLevel('A1', this)" disabled>
                            <div class="text-primary font-black text-lg">A1</div>
                            <div class="text-[10px] text-slate-400 font-bold uppercase tracking-wider">Beginner</div>
                        </button>
                        <button
                            class="level-btn p-4 rounded-2xl bg-white border-2 border-slate-100 transition-all text-left opacity-50 cursor-not-allowed"
                            onclick="game.setLevel('A2', this)" disabled>
                            <div class="text-primary font-black text-lg">A2</div>
                            <div class="text-[10px] text-slate-400 font-bold uppercase tracking-wider">Elementary</div>
                        </button>
                        <button
                            class="level-btn p-4 rounded-2xl bg-white border-2 border-slate-100 transition-all text-left opacity-50 cursor-not-allowed"
                            onclick="game.setLevel('B1', this)" disabled>
                            <div class="text-primary font-black text-lg">B1</div>
                            <div class="text-[10px] text-slate-400 font-bold uppercase tracking-wider">Intermediate
                            </div>
                        </button>
                        <button
                            class="level-btn p-4 rounded-2xl bg-white border-2 border-slate-100 transition-all text-left opacity-50 cursor-not-allowed"
                            onclick="game.setLevel('B2', this)" disabled>
                            <div class="text-primary font-black text-lg">B2</div>
                            <div class="text-[10px] text-slate-400 font-bold uppercase tracking-wider">Upper Inter.
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Timer Mode -->
                <div>
                    <div class="text-[10px] font-black text-slate-400 uppercase mb-2 tracking-widest text-center">Timer
                        Duration</div>
                    <div class="flex gap-2">
                        <button id="timer-standard" onclick="game.setTimerMode(60, this)"
                            class="flex-1 py-3 rounded-xl border-2 border-primary bg-primary-light text-primary font-bold text-sm transition-all">
                            Standard (60s)
                        </button>
                        <button id="timer-beginner" onclick="game.setTimerMode(120, this)"
                            class="flex-1 py-3 rounded-xl border-2 border-slate-100 bg-white text-slate-400 font-bold text-sm transition-all">
                            Beginner (2m)
                        </button>
                    </div>
                </div>

                <div class="pt-2">
                    <button id="btn-start-round" disabled onclick="game.startRound()"
                        class="btn-3d w-full bg-slate-200 text-slate-400 py-4 rounded-2xl font-black text-xl shadow-lg">
                        Select a Level
                    </button>
                </div>
            </div>

            <!-- Tab Content: Online -->
            <div id="content-online" class="hidden space-y-6">
                <div class="bg-blue-50 p-6 rounded-3xl border border-blue-100 space-y-4">
                    <div class="text-center">
                        <div class="text-xl font-black text-blue-600 mb-1">Play with Friends</div>
                        <p class="text-xs text-blue-400 font-medium">Create a private room and share the code</p>
                    </div>

                    <input id="input-host-name" type="text" maxlength="20" placeholder="Your Name (Optional)"
                        class="w-full px-4 py-3 rounded-xl border-2 border-blue-100 text-center text-lg font-bold bg-white">

                    <button onclick="game.createRoom()"
                        class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-lg font-black shadow-lg">
                        Create New Room
                    </button>
                </div>

                <div class="text-center text-[10px] font-black text-slate-300 uppercase tracking-widest">‚Äî OR ‚Äî</div>

                <button onclick="game.showJoinRoom()"
                    class="btn-3d w-full bg-white border-2 border-slate-100 text-slate-600 py-4 rounded-2xl text-lg font-black shadow-sm">
                    Join Existing Room
                </button>
            </div>
            <div class="flex flex-col gap-2 mb-8">
                <button id="btn-how-to-play" onclick="game.showHowToPlay()"
                    class="w-full py-2 text-primary font-bold text-sm flex items-center justify-center gap-1">
                    <span>‚ùî How to Play</span>
                </button>
                <button onclick="game.storage.resetPlayed()"
                    class="text-[10px] text-slate-300 font-bold uppercase tracking-widest hover:text-slate-400 transition-colors">
                    Reset all cards
                </button>
            </div>
        </div>


        <div id="screen-game" class="hidden flex flex-col items-center">
            <!-- Multiplayer turn indicator (MOVED TO TOP) -->
            <div id="multiplayer-turn-indicator"
                class="hidden w-full mb-6 rounded-2xl p-4 border-2 transition-all duration-300">
                <div id="turn-role-badge" class="role-badge hidden"></div>
                <div class="text-lg font-black uppercase tracking-tight leading-none mb-1" id="turn-indicator-text">
                    Your
                    turn!</div>
                <div class="text-xs font-bold opacity-80" id="turn-indicator-subtext"></div>
            </div>

            <div id="card-container"
                class="w-full bg-white rounded-[2rem] shadow-xl border-4 border-primary-light p-8 mb-8 text-center min-h-[380px] flex flex-col justify-between">
                <div>
                    <div id="card-level-tag"
                        class="inline-block px-3 py-1 rounded-full bg-primary-light text-primary text-[10px] font-black mb-4 uppercase">
                        Level A1</div>
                    <h2 id="word-to-guess" class="text-4xl font-black text-slate-800 mb-6 uppercase leading-tight">
                        ...
                    </h2>
                    <ul id="taboo-words" class="space-y-2"></ul>
                </div>
            </div>

            <!-- Main Actions (Skip, Buzzed, Correct) -->
            <div class="flex gap-4 w-full mb-8">
                <button id="btn-skip" onclick="game.skipCard()"
                    class="btn-3d flex-1 bg-slate-200 text-slate-500 py-4 rounded-2xl font-bold">
                    Skip (1/1)
                </button>
                <button id="btn-buzzed" onclick="game.markBuzzed()"
                    class="btn-3d flex-1 bg-red-500 text-white py-4 rounded-2xl font-bold hidden">
                    Buzzed
                </button>
                <button id="btn-correct" onclick="game.nextCard(true)"
                    class="btn-3d flex-[2] bg-green-500 text-white py-4 rounded-2xl font-black text-lg">
                    Correct! ‚úÖ
                </button>
            </div>



            <!-- Start round button for active player -->
            <div id="multiplayer-start-round" class="hidden w-full mb-8">
                <button onclick="game.startMultiplayerRound()"
                    class="btn-3d w-full bg-green-500 text-white py-4 rounded-2xl font-black text-lg">
                    Start Your Round
                </button>
            </div>

            <!-- Multiplayer buzzer for opposing players -->
            <div id="multiplayer-buzzer-container" class="hidden w-full mb-8 flex flex-col items-center">
                <button id="global-buzzer" onclick="game.handleBuzzer()"
                    class="hidden w-32 h-32 bg-red-600 text-white rounded-full font-black text-xl shadow-[0_15px_40px_rgba(220,38,38,0.4)] hover:scale-105 active:scale-95 transition-all flex items-center justify-center border-8 border-red-500 uppercase mb-4">
                    Buzz!
                </button>
                <p class="text-[10px] text-slate-400 font-bold uppercase mt-2 text-center">Buzz if you hear a taboo
                    word!</p>
            </div>

            <!-- Waiting for player message -->
            <div id="multiplayer-waiting"
                class="hidden w-full mb-4 bg-slate-50 border-2 border-slate-200 rounded-2xl p-4">
                <div class="text-sm font-bold text-slate-600" id="waiting-text">Waiting for player to start...</div>
            </div>

            <!-- Player list (multiplayer) -->
            <div id="multiplayer-player-list"
                class="hidden w-full mb-4 bg-white rounded-2xl p-4 border-2 border-slate-100">
                <div class="text-xs text-slate-400 font-bold uppercase mb-2">Players</div>
                <div id="game-players-list" class="space-y-1"></div>
            </div>
        </div>

        <!-- SUMMARY SCREEN -->
        <div id="screen-summary" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üéâ</div>
            <h2 id="summary-title" class="text-3xl font-black text-slate-800 mb-2">Round Finished</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-4 w-full shadow-sm">
                <div id="round-score-val" class="text-6xl font-black text-primary mb-2">0</div>
                <div class="text-xs text-slate-400 uppercase font-black tracking-widest mb-6">Points this round
                </div>

                <div class="flex flex-col items-center py-4">
                    <p class="text-[10px] text-slate-400 font-bold uppercase mt-2">Next round coming up!</p>
                </div>
            </div>

            <div class="flex flex-col gap-3 w-full">
                <button onclick="game.startRound()"
                    class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                    Next Round
                </button>
                <button onclick="game.showEndGame()" class="w-full py-2 text-slate-400 font-bold text-sm underline">
                    Final Score & Breakdown
                </button>
            </div>
        </div>



        <!-- JOIN ROOM SCREEN -->
        <div id="screen-join-room" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üîó</div>
            <h2 class="text-3xl font-black text-slate-800 mb-4">Join Room</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <label class="block text-left text-sm font-bold text-slate-600 mb-2">Room Code</label>
                <input id="input-room-code" type="text" maxlength="4" placeholder="AB12"
                    oninput="this.value = this.value.toUpperCase()"
                    class="w-full px-4 py-3 rounded-xl border-2 border-slate-200 text-center text-2xl font-black room-code-display uppercase mb-4"
                    style="letter-spacing: 0.2em;">
                <label class="block text-left text-sm font-bold text-slate-600 mb-2">Your Name</label>
                <input id="input-player-name" type="text" maxlength="20" placeholder="Enter your name"
                    class="w-full px-4 py-3 rounded-xl border-2 border-slate-200 text-center text-lg font-bold mb-4">
                <button onclick="game.joinRoom()"
                    class="btn-3d w-full bg-slate-800 text-white py-3 rounded-xl font-black">
                    Join
                </button>
                <button onclick="game.showScreen('start')"
                    class="w-full mt-4 text-slate-400 font-bold text-sm underline">
                    Back
                </button>
            </div>
        </div>

        <!-- LOBBY SCREEN -->
        <div id="screen-lobby" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üè†</div>
            <h2 class="text-3xl font-black text-slate-800 mb-4">Room Lobby</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <div class="mb-6">
                    <div class="text-xs text-slate-400 font-bold uppercase mb-2">Room Code</div>
                    <div id="lobby-room-code" class="text-4xl font-black room-code-display text-primary mb-2">----
                    </div>
                    <button id="btn-copy-code" onclick="game.copyRoomCode()"
                        class="text-xs text-slate-500 font-bold underline">
                        Copy Code
                    </button>
                </div>
                <div class="mb-6">
                    <div class="text-xs text-slate-400 font-bold uppercase mb-3 text-left">Players</div>
                    <div id="lobby-players-list" class="space-y-2 text-left"></div>
                </div>
                <div id="lobby-host-controls" class="hidden">
                    <label class="block text-left text-sm font-bold text-slate-600 mb-2">Language</label>
                    <div class="flex gap-2 mb-4">
                        <button id="lobby-lang-fr" onclick="game.setMultiplayerLanguage('fr', this)"
                            class="flex-1 py-3 rounded-xl border-2 border-slate-200 bg-white text-slate-600 font-bold text-sm transition-all flex items-center justify-center gap-2">
                            <span class="emoji-fr">üá´üá∑</span> Fran√ßais
                        </button>
                        <button id="lobby-lang-en" onclick="game.setMultiplayerLanguage('en', this)"
                            class="flex-1 py-3 rounded-xl border-2 border-slate-200 bg-white text-slate-600 font-bold text-sm transition-all flex items-center justify-center gap-2">
                            <span class="emoji-en">üá¨üáß</span> English
                        </button>
                    </div>

                    <label class="block text-left text-sm font-bold text-slate-600 mb-2">Select Level</label>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <button onclick="game.setMultiplayerLevel('A1', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-primary text-lg">A1</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Beginner</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('A2', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-primary text-lg">A2</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Elementary</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('B1', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-primary text-lg">B1</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Intermediate</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('B2', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-primary text-lg">B2</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Upper Inter.</div>
                        </button>
                    </div>

                    <label class="block text-left text-sm font-bold text-slate-600 mb-2">Timer Duration</label>
                    <div class="flex gap-2 mb-4">
                        <button id="lobby-timer-standard" onclick="game.setMultiplayerTimer(60, this)"
                            class="flex-1 py-3 rounded-xl border-2 border-primary bg-primary-light text-primary font-bold text-sm transition-all">
                            Standard (60s)
                        </button>
                        <button id="lobby-timer-beginner" onclick="game.setMultiplayerTimer(120, this)"
                            class="flex-1 py-3 rounded-xl border-2 border-slate-100 bg-white text-slate-400 font-bold text-sm transition-all">
                            Beginner (2m)
                        </button>
                    </div>

                    <button id="btn-start-game" disabled onclick="game.startMultiplayerGame()"
                        class="btn-3d w-full bg-slate-200 text-slate-400 py-4 rounded-2xl text-xl font-black">
                        Select Level to Start
                    </button>
                </div>
                <div id="lobby-waiting" class="text-slate-500 text-sm">
                    Waiting for host to start the game...
                </div>
            </div>
            <button onclick="game.leaveRoom()" class="w-full py-2 text-slate-400 font-bold text-sm underline">
                Leave Room
            </button>
        </div>

        <!-- END GAME SCREEN -->
        <div id="screen-endgame" class="hidden text-center flex flex-col items-center w-full">
            <h2 class="text-3xl font-black text-slate-800 mb-2">Session Recap</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <div class="flex justify-around mb-6 pb-6 border-b border-slate-100">
                    <div class="text-center">
                        <div id="total-final-score" class="text-4xl font-black text-primary">0</div>
                        <div class="text-center text-[10px] text-slate-400 font-black uppercase">Total Points</div>
                    </div>
                    <div class="text-center">
                        <div id="total-rounds-count" class="text-4xl font-black text-slate-800">0</div>
                        <div class="text-[10px] text-slate-400 font-black uppercase">Rounds</div>
                    </div>
                </div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Round Breakdown</h3>
                <div id="round-history-list" class="space-y-2 mb-6"></div>

                <button id="btn-show-review" onclick="game.showWordReview()"
                    class="w-full bg-primary-light text-primary py-3 rounded-2xl font-black text-sm">
                    Review Guessed Words?
                </button>

                <div id="review-section" class="hidden mt-6 text-left">
                    <h3 class="text-[10px] font-black text-slate-400 uppercase mb-3">Word Review (Click for
                        Definition)
                    </h3>
                    <div id="word-review-list" class="space-y-2"></div>
                </div>
            </div>
            <button onclick="game.returnToMainMenu()"
                class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                Main Menu
            </button>
        </div>

        <!-- MULTIPLAYER END GAME SCREEN -->
        <div id="screen-multiplayer-endgame" class="hidden text-center flex flex-col items-center w-full">
            <div id="winner-indicator" class="mb-4">
                <div id="winner-emoji" class="text-6xl mb-2"></div>
                <h2 id="winner-title" class="text-3xl font-black text-slate-800 mb-2"></h2>
                <p id="winner-subtitle" class="text-sm text-slate-500 mb-4"></p>
            </div>

            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <!-- Team Scores Summary -->
                <div id="team-scores-container" class="hidden mb-8">
                    <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Team Results</h3>
                    <div class="flex gap-3">
                        <div id="team-a-score-card" class="team-score-card team-a">
                            <div class="text-[10px] font-black opacity-60">TEAM A</div>
                            <div id="team-a-total-pts" class="text-3xl font-black">0</div>
                            <div class="text-[9px] font-bold">TOTAL POINTS</div>
                        </div>
                        <div id="team-b-score-card" class="team-score-card team-b">
                            <div class="text-[10px] font-black opacity-60">TEAM B</div>
                            <div id="team-b-total-pts" class="text-3xl font-black">0</div>
                            <div class="text-[9px] font-bold">TOTAL POINTS</div>
                        </div>
                    </div>
                </div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Player Standings</h3>
                <div id="final-scores-list" class="space-y-2 mb-6"></div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Your Words</h3>
                <p class="text-xs text-slate-500 mb-3 text-left">All the words you had to describe:</p>
                <div id="my-words-list" class="space-y-2 mb-6"></div>
            </div>

            <button onclick="game.returnToMainMenu()"
                class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                Main Menu
            </button>
        </div>
    </main>

    <!-- MODALS -->
    <div id="modal-end-turn" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">üîî</div>
            <h3 class="text-xl font-black mb-2">Buzzer!</h3>
            <p class="text-slate-500 mb-6 text-sm" id="buzz-modal-text">Did you get <span id="last-word-hint"
                    class="font-bold text-primary"></span> correctly?</p>
            <div class="flex gap-3">
                <button onclick="game.handleBuzzResponse(false)"
                    class="flex-1 bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">No</button>
                <button onclick="game.handleBuzzResponse(true)"
                    class="flex-1 bg-primary text-white py-3 rounded-xl font-bold">Yes!</button>
            </div>
        </div>
    </div>

    <!-- FINISH GAME PROMPT MODAL -->
    <div id="modal-finish-game-prompt"
        class="hidden fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-[200] flex items-center justify-center p-4">
        <div class="bg-white rounded-3xl p-8 max-w-sm w-full text-center shadow-2xl">
            <div class="text-4xl mb-4">‚öñÔ∏è</div>
            <h3 class="text-2xl font-black text-slate-800 mb-2">Teams Unbalanced</h3>
            <p id="finish-game-msg" class="text-slate-500 mb-8 leading-relaxed">Too many players have left. The game
                must end to keep it fair for everyone.</p>
            <div class="space-y-3">
                <button id="finish-and-see-results-btn" onclick="game.multiplayer.endGame()"
                    class="w-full bg-slate-800 text-white py-4 rounded-2xl font-black text-lg shadow-lg hover:bg-slate-700 transition-colors">
                    See Game Results
                </button>
                <button id="continue-anyway-btn" onclick="game.multiplayer.continueAnyway()"
                    class="hidden w-full bg-slate-100 text-slate-600 py-3 rounded-2xl font-black text-sm">
                    Continue anyway
                </button>
            </div>
        </div>
    </div>

    <!-- HOW TO PLAY MODAL -->
    <div id="modal-how-to-play" class="hidden fixed inset-0 z-[150] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-sm w-full max-h-[80vh] overflow-y-auto no-scrollbar">
            <div class="text-4xl mb-4 text-center">üìñ</div>
            <h3 class="text-2xl font-black mb-4 text-center">How to Play</h3>

            <div class="space-y-6 text-sm text-slate-600">
                <section>
                    <h4 class="font-black text-slate-800 uppercase text-[10px] mb-2 text-primary tracking-widest">The
                        Goal</h4>
                    <p>Describe the word at the top without using any of the 5 taboo words listed below it!</p>
                </section>

                <section>
                    <h4 class="font-black text-slate-800 uppercase text-[10px] mb-2 text-primary tracking-widest">The
                        Modes</h4>
                    <ul class="space-y-3">
                        <li class="flex gap-3">
                            <span class="text-lg">üì±</span>
                            <span><strong>Local Pass-and-Play:</strong> One phone, in the same room. Select
                                <strong>Standard</strong> or <strong>Beginner</strong> timer, then pass the phone to the
                                next player after each round.</span>
                        </li>
                        <li class="flex gap-3">
                            <span class="text-lg">üåê</span>
                            <span><strong>Online Multiplayer:</strong> Play with friends on their own devices. One
                                person hosts and sets the timer, others join with a 4-letter code.</span>
                        </li>
                    </ul>
                </section>

                <section>
                    <h4 class="font-black text-slate-800 uppercase text-[10px] mb-2 text-primary tracking-widest">The
                        Buzzer</h4>
                    <p>In <strong>Online Team</strong> mode, the opposing team has a <strong>BUZZ</strong> button. If
                        they hear you say a taboo word, they'll buzz you and you lose the point!</p>
                </section>
            </div>

            <button onclick="game.hideHowToPlay()"
                class="w-full mt-8 bg-slate-800 text-white py-4 rounded-2xl font-black">
                Got it!
            </button>
        </div>
    </div>

    <!-- Leave Game Modal - Step 1: Choose action -->
    <div id="modal-leave-game" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">üëã</div>
            <h3 class="text-xl font-black mb-2">Leave Game?</h3>
            <p class="text-slate-500 mb-6 text-sm">What would you like to do?</p>
            <div class="flex flex-col gap-3">
                <button id="btn-leave-individual" onclick="game.confirmLeaveAction('leave')"
                    class="w-full bg-orange-500 text-white py-3 rounded-xl font-bold">
                    Leave Game
                </button>
                <p id="leave-game-warning"
                    class="hidden text-orange-600 text-[10px] font-black uppercase tracking-tighter bg-orange-50 p-3 rounded-xl border border-orange-100 leading-tight">
                </p>
                <button id="end-for-all-btn" onclick="game.confirmLeaveAction('endAll')"
                    class="w-full bg-red-500 text-white py-3 rounded-xl font-bold">
                    End for All Players
                </button>
                <button onclick="game.hideLeaveGameModal()"
                    class="w-full bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Leave Game Modal - Step 2: Confirm action -->
    <div id="modal-confirm-leave" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">‚ö†Ô∏è</div>
            <h3 class="text-xl font-black mb-2">Are you sure?</h3>
            <p id="confirm-leave-text" class="text-slate-500 mb-6 text-sm">This action cannot be undone.</p>
            <div class="flex gap-3">
                <button onclick="game.cancelLeaveConfirm()"
                    class="flex-1 bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">Cancel</button>
                <button id="confirm-leave-btn" onclick="game.executeLeaveAction()"
                    class="flex-1 bg-red-500 text-white py-3 rounded-xl font-bold">Yes, I'm sure</button>
            </div>
        </div>
    </div>

    <script>
        const REMOTE_URL_FR = 'https://raw.githubusercontent.com/meemiemeemie/french-taboo/main/word-list.csv';
        const REMOTE_URL_EN = 'https://raw.githubusercontent.com/meemiemeemie/french-taboo/main/english_words.csv';

        /**
         * FIREBASE CONFIGURATION
         * IMPORTANT: In a production environment, restrict your API key to your domain 
         * in the Google Cloud Console (APIs & Services > Credentials).
         */
        const firebaseConfig = {
            apiKey: "AIzaSyDwuX6WaTRSLAeDqdex0VyapFKYEJ5OGfQ",
            authDomain: "french-taboo.firebaseapp.com",
            databaseURL: "https://french-taboo-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "french-taboo",
            storageBucket: "french-taboo.firebasestorage.app",
            messagingSenderId: "876947251507",
            appId: "1:876947251507:web:3a1712871ea0fa411e1e46",
            measurementId: "G-LPCQEL2RXM"
        };

        class StorageManager {
            constructor() {
                this.PREFIX = 'taboo_';
            }

            save(key, val) {
                try {
                    localStorage.setItem(this.PREFIX + key, JSON.stringify(val));
                } catch (e) {
                    console.error('Storage error:', e);
                }
            }

            get(key) {
                try {
                    const item = localStorage.getItem(this.PREFIX + key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    return null;
                }
            }

            getPlayerId() { return this.get('player_id'); }
            savePlayerId(id) { this.save('player_id', id); }

            getPlayerName() { return this.get('player_name'); }
            savePlayerName(name) { this.save('player_name', name); }

            getRoomCode() { return this.get('room_code'); }
            saveRoomCode(code) { this.save('room_code', code); }
            clearRoomCode() { localStorage.removeItem(this.PREFIX + 'room_code'); }

            getGameHistory() { return this.get('history') || []; }
            addGameToHistory(game) {
                const history = this.getGameHistory();
                history.unshift({ ...game, timestamp: Date.now() });
                this.save('history', history.slice(0, 20));
            }

            getDescribedWords() { return this.get('described_words') || []; }
            addDescribedWord(wordData) {
                const words = this.getDescribedWords();
                if (!words.find(w => w.word === wordData.word)) {
                    words.unshift({ ...wordData, timestamp: Date.now() });
                    this.save('described_words', words.slice(0, 500));
                }
            }

            updateLastWordStatus(status) {
                const words = this.getDescribedWords();
                if (words.length > 0) {
                    words[0].status = status;
                    this.save('described_words', words);
                }
            }

            resetPlayed() {
                if (confirm('Are you sure you want to reset all played cards? This will allow previously played words to appear again.')) {
                    this.save('described_words', []);
                    alert('All cards have been reset!');
                    location.reload();
                }
            }
        }

        class MultiplayerManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.storage = new StorageManager();
                this.db = null;
                this.roomRef = null;
                this.playerId = this.storage.getPlayerId();
                this.roomCode = null;
                this.isHost = false;
                this.currentHostId = null;
                this.players = {};
                this.gameState = null;
                this.sessionPlayedIds = new Set();
                this.listeners = [];
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
            }

            initialize() {
                try {
                    if (typeof firebase === 'undefined') {
                        console.error('Firebase SDK not loaded');
                        return false;
                    }

                    if (!firebase.apps || firebase.apps.length === 0) {
                        if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                            console.warn('Firebase configuration is incomplete.');
                            return false;
                        }
                        firebase.initializeApp(firebaseConfig);
                    }
                    this.db = firebase.database();

                    if (!this.playerId) {
                        this.playerId = this.generatePlayerId();
                        this.storage.savePlayerId(this.playerId);
                    }

                    // Track server time offset
                    this.serverTimeOffset = 0;
                    this.db.ref('.info/serverTimeOffset').on('value', (snap) => {
                        this.serverTimeOffset = snap.val() || 0;
                    });

                    // Add presence logic
                    const connectedRef = this.db.ref('.info/connected');
                    connectedRef.on('value', (snap) => {
                        if (snap.val() === true && this.roomRef) {
                            const pRef = this.roomRef.child(`players/${this.playerId}`);
                            pRef.onDisconnect().remove();
                        }
                    });

                } catch (e) {
                    console.error('Firebase initialization error:', e);
                    return false;
                }
                return true;
            }

            generatePlayerId() {
                return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let code = '';
                for (let i = 0; i < 4; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }

            async createRoom(hostName) {
                try {
                    if (!this.db) {
                        if (!this.initialize()) return null;
                    }

                    let attempts = 0;
                    let code;
                    let roomExists = true;

                    // Try to generate unique code (max 10 attempts)
                    while (roomExists && attempts < 10) {
                        code = this.generateRoomCode();
                        const roomPath = `rooms/${code}`;
                        const snapshot = await this.db.ref(roomPath).once('value');
                        roomExists = snapshot.exists();
                        attempts++;
                    }

                    if (roomExists) {
                        alert('Failed to create room. Please try again.');
                        return null;
                    }

                    this.roomCode = code;
                    this.isHost = true;
                    this.currentHostId = this.playerId;

                    const roomPath = `rooms/${code}`;
                    this.roomRef = this.db.ref(roomPath);
                    this.storage.saveRoomCode(code);
                    this.storage.savePlayerName(hostName || 'Host');

                    // Create room with expiration (1 hour)
                    const expirationTime = Date.now() + (60 * 60 * 1000);
                    await this.roomRef.set({
                        host: this.playerId,
                        createdAt: firebase.database.ServerValue.TIMESTAMP,
                        expiresAt: expirationTime,
                        gameState: {
                            status: 'lobby',
                            level: null,
                            currentPlayer: null,
                            currentCard: null,
                            timer: 60,
                            roundActive: false,
                            playedIds: {},
                            language: this.game.activeLanguage || 'fr'
                        },
                        players: {}
                    });

                    // Add host as first player
                    await this.joinRoomAsPlayer(hostName || 'Host');
                    this.setupRoomListeners();

                    // Set up individual player cleanup on disconnect
                    this.roomRef.child(`players/${this.playerId}`).onDisconnect().remove();

                    return code;
                } catch (error) {
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Please check your connection and try again.');
                    return null;
                }
            }

            async joinRoom(code, playerName) {
                try {
                    if (!this.db) {
                        if (!this.initialize()) return false;
                    }

                    this.roomCode = code;
                    const roomPath = `rooms/${code}`;
                    this.roomRef = this.db.ref(roomPath);

                    // Check if room exists
                    const snapshot = await this.roomRef.once('value');
                    if (!snapshot.exists()) {
                        alert('Room not found. Please check the room code.');
                        return false;
                    }

                    const roomData = snapshot.val();
                    if (roomData.gameState && roomData.gameState.status === 'playing') {
                        // Check if there are actually any active players
                        const activePlayers = Object.values(roomData.players || {}).filter(p => p.online !== false);

                        if (activePlayers.length > 0) {
                            // Allow joining during game but show message only if there are people playing
                            const joinDuringGame = confirm('Game is already in progress. You can join as a spectator. Continue?');
                            if (!joinDuringGame) return false;
                        }
                    }

                    // Check player limit (8 players max)
                    const currentPlayers = Object.keys(roomData.players || {}).length;
                    if (currentPlayers >= 8) {
                        alert('Room is full (8 players maximum).');
                        return false;
                    }

                    this.isHost = roomData.host === this.playerId;
                    this.currentHostId = roomData.host;
                    this.storage.saveRoomCode(code);
                    this.storage.savePlayerName(playerName);
                    await this.joinRoomAsPlayer(playerName);
                    this.setupRoomListeners();
                    return true;
                } catch (error) {
                    console.error('Error joining room:', error);
                    alert('Failed to join room. Please check your connection and try again.');
                    return false;
                }
            }

            async tryAutoRejoin() {
                try {
                    const savedCode = this.storage.getRoomCode();
                    const savedName = this.storage.getPlayerName();

                    if (!savedCode || !savedName) return false;

                    if (!this.db) {
                        if (!this.initialize()) return false;
                    }

                    console.log('Attempting auto-rejoin to:', savedCode);

                    const roomPath = `rooms/${savedCode}`;
                    const snapshot = await this.db.ref(roomPath).once('value');

                    if (!snapshot.exists()) {
                        console.log('Room no longer exists');
                        this.storage.clearRoomCode();
                        return false;
                    }

                    const roomData = snapshot.val();
                    // If room exists and player was in it (or room is still open)
                    // We just join normally. joinRoom handles the rest.
                    return await this.joinRoom(savedCode, savedName);
                } catch (e) {
                    console.error('Auto-rejoin error:', e);
                    return false;
                }
            }

            async joinRoomAsPlayer(playerName) {
                if (!this.roomRef) return;

                // Sanitize player name
                const sanitizedName = playerName.substring(0, 20).replace(/[<>]/g, '') || 'Player';

                const playerData = {
                    name: sanitizedName,
                    joinedAt: firebase.database.ServerValue.TIMESTAMP,
                    score: 0,
                    team: null,
                    online: true
                };

                await this.roomRef.child(`players/${this.playerId}`).set(playerData);
                // Keep online status synced
                this.roomRef.child(`players/${this.playerId}/online`).onDisconnect().set(false);
            }

            setupRoomListeners() {
                if (!this.roomRef) return;

                // Listen to players
                this.roomRef.child('players').on('value', async (snapshot) => {
                    this.players = snapshot.val() || {};
                    this.updatePlayersList();

                    // Host Migration Logic
                    if (this.roomRef && this.players) {
                        const currentHostId = this.currentHostId;

                        // If host is missing or offline
                        if (!currentHostId || !this.players[currentHostId] || this.players[currentHostId].online === false) {
                            // Find next available player (sorted by joinedAt)
                            const playerArray = Object.entries(this.players)
                                .map(([id, data]) => ({ id, ...data }))
                                .filter(p => p.online !== false)
                                .sort((a, b) => (a.joinedAt || 0) - (b.joinedAt || 0));

                            if (playerArray.length > 0) {
                                const nextHostId = playerArray[0].id;
                                // If I am the next in line, nominate myself as host
                                if (nextHostId === this.playerId && currentHostId !== this.playerId) {
                                    console.log("Promoting self to Host...");
                                    await this.roomRef.child('host').set(this.playerId);
                                }
                            }
                        }
                    }
                });

                // Listen to Host changes
                this.roomRef.child('host').on('value', (snapshot) => {
                    const newHostId = snapshot.val();
                    this.currentHostId = newHostId;
                    const wasHost = this.isHost;
                    this.isHost = (newHostId === this.playerId);

                    if (this.isHost && !wasHost) {
                        console.log("I am the new Host! Starting timer authority...");
                        this.startHostTimer();
                        this.validateRoomState(); // Immediate check after promotion
                        this.updatePlayersList();
                    }
                });

                this.roomRef.child('players').on('child_removed', (snapshot) => {
                    if (this.isHost && this.gameState && this.gameState.status === 'playing') {
                        this.validateRoomState();
                    }
                });

                // Listen to game state
                this.roomRef.child('gameState').on('value', (snapshot) => {
                    this.gameState = snapshot.val();
                    if (this.gameState) {
                        // Sync played card IDs
                        if (this.gameState.playedIds) {
                            this.sessionPlayedIds = new Set(Object.keys(this.gameState.playedIds));
                        } else {
                            this.sessionPlayedIds = new Set();
                        }
                        this.handleGameStateChange();
                    }
                });

                // Listen to buzz events separately for better handling
                this.roomRef.child('gameState/lastBuzz').on('value', (snapshot) => {
                    const buzzData = snapshot.val();
                    if (buzzData && this.gameState && this.gameState.roundActive) {
                        const currentPlayerId = this.gameState.currentPlayer;
                        if (buzzData.playerId !== currentPlayerId && currentPlayerId === this.playerId) {
                            // Someone buzzed me - show modal
                            this.showBuzzModal(buzzData);
                        }
                    }
                });

                // Handle connection state
                const connectedRef = this.db.ref('.info/connected');
                connectedRef.on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        // Connected
                        this.reconnectAttempts = 0;
                        this.hideConnectionError();
                    } else {
                        // Disconnected
                        this.showConnectionError();
                        this.attemptReconnect();
                    }
                });

                // Handle disconnections
                if (this.playerId) {
                    this.roomRef.child(`players/${this.playerId}`).onDisconnect().remove();
                }

                // Start host timer if applicable
                this.startHostTimer();
            }

            startHostTimer() {
                if (!this.isHost || this.hostTimer) return;

                this.hostTimer = setInterval(async () => {
                    // Watchdog: If round is active and time exceeded by 2 seconds, force end
                    if (this.gameState && this.gameState.roundActive && this.gameState.roundStartTime) {
                        const now = Date.now() + (this.serverTimeOffset || 0);
                        const elapsed = (now - this.gameState.roundStartTime) / 1000;
                        const limit = this.gameState.timer + 2; // 2 seconds grace

                        if (elapsed > limit) {
                            console.warn("Host forcing end of round due to timeout");
                            this.endRound(false, true); // Force end
                        }
                    }
                }, 1000);
            }

            sanitizeKey(key) {
                if (!key) return "unknown";
                // Firebase keys cannot contain . $ # [ ] /
                return key.toString().replace(/[\.\$#\[\]\/]/g, '_');
            }

            async addSessionPlayed(id) {
                if (!this.roomRef || !id) return;
                try {
                    const safeId = this.sanitizeKey(id);
                    await this.roomRef.child(`gameState/playedIds/${safeId}`).set(true);
                } catch (e) {
                    console.error("Error adding played ID:", e);
                }
            }

            showConnectionError() {
                const dot = document.getElementById('connection-dot');
                const text = document.getElementById('connection-text');
                if (dot) dot.className = 'w-2.5 h-2.5 rounded-full bg-red-500 animate-pulse';
                if (text) text.textContent = 'Disconnected';
                console.warn('Connection lost. Attempting to reconnect...');
            }

            hideConnectionError() {
                const dot = document.getElementById('connection-dot');
                const text = document.getElementById('connection-text');
                if (dot) dot.className = 'w-2.5 h-2.5 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.5)]';
                if (text) text.textContent = 'Online';
            }

            async attemptReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    alert('Connection lost. Please refresh the page.');
                    return;
                }

                this.reconnectAttempts++;
                setTimeout(async () => {
                    if (this.roomCode && !this.db.ref('.info/connected').val()) {
                        try {
                            // Try to rejoin room
                            const roomPath = `rooms/${this.roomCode}`;
                            const snapshot = await this.db.ref(roomPath).once('value');
                            if (snapshot.exists()) {
                                this.roomRef = this.db.ref(roomPath);
                                this.setupRoomListeners();
                            }
                        } catch (e) {
                            console.error('Reconnection failed:', e);
                            this.attemptReconnect();
                        }
                    }
                }, 2000 * this.reconnectAttempts);
            }

            updatePlayersList() {
                const listEl = document.getElementById('lobby-players-list');
                const gameListEl = document.getElementById('game-players-list');
                if (!listEl && !gameListEl) return;

                const playerArray = Object.entries(this.players).map(([id, data]) => ({
                    id,
                    ...data
                }));

                const colors = ['#ec4899', '#3b82f6', '#8b5cf6', '#f59e0b', '#10b981', '#ef4444', '#06b6d4', '#f97316'];
                let colorIndex = 0;

                const renderPlayer = (player, isGame = false) => {
                    const color = colors[colorIndex % colors.length];
                    colorIndex++;
                    const isCurrentPlayer = player.id === this.playerId;
                    const isHostPlayer = this.isHost && player.id === this.playerId;
                    const hostBadge = isHostPlayer ? '<span class="text-[8px] bg-primary-light text-primary px-2 py-0.5 rounded-full ml-2">HOST</span>' : '';
                    const teamBadge = player.team ? `<span class="team-indicator ${player.team === 'A' ? 'team-a' : 'team-b'}">Team ${player.team}</span>` : '';
                    const onlineStatus = player.online === false ? '<span class="text-[8px] text-slate-300 ml-2 italic">(offline)</span>' : '';

                    const div = document.createElement('div');
                    div.className = `flex justify-between items-center p-2 rounded-lg ${isCurrentPlayer ? 'bg-primary-light border-2 border-primary' : 'bg-slate-50'} ${player.online === false ? 'opacity-50' : ''}`;
                    div.innerHTML = `
                        <div class="flex items-center">
                            <span class="player-color-dot" style="background-color: ${player.online === false ? '#cbd5e1' : color}"></span>
                            <span class="font-bold text-slate-700">${player.name}</span>
                            ${hostBadge}
                            ${teamBadge}
                            ${onlineStatus}
                        </div>
                        ${isGame ? `<span class="font-black text-slate-800">${player.score || 0}</span>` : ''}
                    `;
                    return div;
                };

                if (listEl) {
                    listEl.innerHTML = '';
                    const fragment = document.createDocumentFragment();
                    playerArray.forEach(player => {
                        fragment.appendChild(renderPlayer(player, false));
                    });
                    listEl.appendChild(fragment);
                }

                if (gameListEl) {
                    gameListEl.innerHTML = '';
                    const fragment = document.createDocumentFragment();
                    playerArray.forEach(player => {
                        fragment.appendChild(renderPlayer(player, true));
                    });
                    gameListEl.appendChild(fragment);
                }

                // Show/hide host controls
                const hostControls = document.getElementById('lobby-host-controls');
                const waitingMsg = document.getElementById('lobby-waiting');
                if (hostControls && waitingMsg) {
                    if (this.isHost) {
                        hostControls.classList.remove('hidden');
                        waitingMsg.classList.add('hidden');
                    } else {
                        hostControls.classList.add('hidden');
                        waitingMsg.classList.remove('hidden');
                    }
                }
            }

            async setTimer(seconds) {
                if (!this.isHost || !this.roomRef) return;
                try {
                    await this.roomRef.child('gameState/timer').set(seconds);
                } catch (e) {
                    console.error("Error setting timer:", e);
                }
            }

            async setLanguage(lang) {
                if (!this.isHost || !this.roomRef) return;
                try {
                    await this.roomRef.child('gameState/language').set(lang);
                } catch (e) {
                    console.error("Error setting language:", e);
                }
            }

            async startGame(level) {
                if (!this.isHost || !this.roomRef) return;

                const playerArray = Object.keys(this.players);
                if (playerArray.length < 2) {
                    alert('Need at least 2 players to start!');
                    return;
                }

                // Determine game mode based on player count
                let teams = null;
                let turnOrder = [];

                if (playerArray.length === 2 || playerArray.length === 3) {
                    // Free-for-all Mode for 2-3 players
                    turnOrder = [...playerArray].sort(() => Math.random() - 0.5);
                } else {
                    // Team Mode for 4+ players (including 5, 7 with uneven teams)
                    const teamData = this.formTeams(playerArray);
                    teams = teamData.teams;
                    turnOrder = teamData.turnOrder;
                }

                // Determine first player
                const firstPlayer = turnOrder[0];

                await this.roomRef.child('gameState').set({
                    status: 'playing',
                    level: level,
                    currentPlayer: firstPlayer,
                    currentCard: null,
                    timer: this.game.timeLeft, // Use currently selected timer duration
                    roundActive: false,
                    teams: teams,
                    turnOrder: turnOrder,
                    currentTurnIndex: 0,
                    initialPlayerCount: playerArray.length
                });
            }

            formTeams(playerIds) {
                // Shuffle players first
                const shuffled = [...playerIds].sort(() => Math.random() - 0.5);
                const teams = { A: [], B: [] };

                // Distribute players and build interleaved turn order
                // A1, B1, A2, B2, ...
                const turnOrder = [];

                // Split into two teams (can be uneven for 5, 7 players)
                // For odd numbers, randomly decide which team gets the extra player
                const totalPlayers = shuffled.length;
                const teamASize = Math.floor(totalPlayers / 2);
                const teamBSize = totalPlayers - teamASize;

                // Randomly decide which team gets the extra player for odd counts
                const teamAGetsExtra = Math.random() < 0.5;
                const teamA = teamAGetsExtra && totalPlayers % 2 === 1
                    ? shuffled.slice(0, teamASize + 1)
                    : shuffled.slice(0, teamASize);
                const teamB = teamAGetsExtra && totalPlayers % 2 === 1
                    ? shuffled.slice(teamASize + 1)
                    : shuffled.slice(teamASize);

                // Assign to team objects and update DB
                teamA.forEach(id => {
                    teams.A.push(id);
                    this.roomRef.child(`players/${id}/team`).set('A');
                });

                teamB.forEach(id => {
                    teams.B.push(id);
                    this.roomRef.child(`players/${id}/team`).set('B');
                });

                // Create interleaved order (A1, B1, A2, B2, ...)
                const maxTeamSize = Math.max(teamA.length, teamB.length);
                for (let i = 0; i < maxTeamSize; i++) {
                    if (teamA[i]) turnOrder.push(teamA[i]);
                    if (teamB[i]) turnOrder.push(teamB[i]);
                }

                return { teams, turnOrder };
            }

            async startRound() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return; // Not this player's turn

                // Get a random card
                const pool = this.game.getPool(this.gameState.level);
                if (pool.length === 0) {
                    await this.endGame();
                    return;
                }

                const card = pool[Math.floor(Math.random() * pool.length)];
                this.game.currentCard = card;
                await this.addSessionPlayed(card.id); // Mark as played immediately in session

                await this.roomRef.child('gameState').update({
                    currentCard: card,
                    timer: this.gameState.timer, // Use the room's set timer
                    roundActive: true,
                    roundStartTime: firebase.database.ServerValue.TIMESTAMP
                });

                // Reset skip limit for the round
                this.game.skips = 1;

                // Display card immediately
                this.game.displayCard(card);

                // Display card immediately
                this.game.displayCard(card);
            }

            async nextCard(scored) {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;

                if (this.game.currentCard) {
                    const status = scored ? 'correct' : 'skipped';
                    this.game.wordLog.push({
                        word: this.game.currentCard.word,
                        type: this.game.currentCard.type,
                        level: this.game.currentCard.level,
                        status: status
                    });
                    this.storage.updateLastWordStatus(status);

                    if (scored) {
                        const currentScore = this.players[this.playerId]?.score || 0;
                        await this.roomRef.child(`players/${this.playerId}/score`).set(currentScore + 1);
                    }
                    await this.addSessionPlayed(this.game.currentCard.id);
                }

                // Get next card
                const pool = this.game.getPool(this.gameState.level);
                if (pool.length === 0) {
                    await this.endRound(false);
                    return;
                }

                const card = pool[Math.floor(Math.random() * pool.length)];
                this.game.currentCard = card;
                await this.addSessionPlayed(card.id);

                // Update Firebase with new card and clear buzz state
                try {
                    await this.roomRef.child('gameState').update({
                        currentCard: card,
                        lastBuzz: null
                    });
                } catch (e) {
                    console.error("Error updating next card:", e);
                }

                // Display card immediately
                this.game.displayCard(card);
            }

            async markBuzzed() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;
                if (!this.gameState.roundActive) return;

                // Clear buzz event
                await this.roomRef.child('gameState/lastBuzz').set(null);

                // Mark card as buzzed (remove from play, no score)
                if (this.game.currentCard) {
                    this.game.wordLog.push({
                        word: this.game.currentCard.word,
                        type: this.game.currentCard.type,
                        level: this.game.currentCard.level,
                        status: 'timeout'
                    });
                    this.storage.updateLastWordStatus('timeout');
                    await this.addSessionPlayed(this.game.currentCard.id);
                }

                // Get next card
                await this.nextCard(false);
            }

            async skipCard() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;

                if (this.game.skips > 0) {
                    this.game.skips--;
                    await this.nextCard(false);
                }
            }

            async buzzPlayer() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId === this.playerId) return; // Can't buzz yourself
                if (!this.gameState.roundActive) return; // Round not active

                // Send buzz event
                await this.roomRef.child('gameState/lastBuzz').set({
                    playerId: this.playerId,
                    playerName: this.players[this.playerId]?.name || 'Unknown',
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                this.game.playObnoxiousBuzzer();
            }

            async endRound(lastCorrect, force = false) {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (!force && currentPlayerId !== this.playerId) return;

                // Prevent multiple calls
                if (this.endingRound) return;
                this.endingRound = true;

                if (this.game.currentCard) {
                    const lastLogIdx = this.game.wordLog.length - 1;
                    const lastLogItem = lastLogIdx >= 0 ? this.game.wordLog[lastLogIdx] : null;

                    // Prevent duplicate logging if the card was just skipped (and thus already logged)
                    // or if it was just logged as timeout in a race condition
                    if (!lastLogItem || lastLogItem.word !== this.game.currentCard.word) {
                        const status = lastCorrect ? 'correct' : 'timeout';
                        this.game.wordLog.push({
                            word: this.game.currentCard.word,
                            type: this.game.currentCard.type,
                            level: this.game.currentCard.level,
                            status: status
                        });
                        this.storage.updateLastWordStatus(status);
                    }
                }

                if (lastCorrect && this.game.currentCard) {
                    const currentScore = this.players[this.playerId]?.score || 0;
                    await this.roomRef.child(`players/${this.playerId}/score`).set(currentScore + 1);
                }

                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }

                // Move to next player
                const turnOrder = this.gameState.turnOrder || Object.keys(this.players);
                const currentIndex = this.gameState.currentTurnIndex || 0;
                const nextIndex = (currentIndex + 1) % turnOrder.length;
                const nextPlayer = turnOrder[nextIndex];

                await this.roomRef.child('gameState').update({
                    currentPlayer: nextPlayer,
                    currentCard: null,
                    roundActive: false,
                    timer: this.gameState.timer,
                    currentTurnIndex: nextIndex
                });

                // Reset flag after a delay
                setTimeout(() => {
                    this.endingRound = false;
                }, 1000);
            }

            async endGame() {
                if (!this.roomRef) return;

                // robustly clear game state
                await this.roomRef.child('gameState').update({
                    status: 'finished',
                    roundActive: false,
                    forcedFinish: null,
                    promptFinish: null,
                    currentCard: null,
                    timer: 60 // Reset timer to standard to stop any weird loops
                });

                // Hide any visible turn indicators
                const turnIndicator = document.getElementById('multiplayer-turn-indicator');
                if (turnIndicator) turnIndicator.classList.add('hidden');
                const yourBadge = document.getElementById('your-team-badge');
                if (yourBadge) yourBadge.classList.add('hidden');
            }

            handleGameStateChange() {
                if (!this.gameState) return;

                // Update UI based on game state
                if (this.gameState.status === 'playing') {
                    this.game.showScreen('game');
                    // Sync level and update stack count
                    if (this.gameState.level) {
                        this.game.selectedLevel = this.gameState.level;
                    }
                    if (this.gameState.language && this.gameState.language !== this.game.activeLanguage) {
                        this.game.setLanguage(this.gameState.language);
                    }
                    // Update stack display after ensuring language/level are set
                    this.game.updateStackDisplay();
                    this.updateGameUI();
                } else if (this.gameState.status === 'lobby') {
                    this.game.showScreen('lobby');
                    // Sync language in lobby too
                    if (this.gameState.language && this.gameState.language !== this.game.activeLanguage) {
                        this.game.setLanguage(this.gameState.language);
                    }
                } else if (this.gameState.status === 'finished') {
                    // Game finished - show multiplayer end game screen
                    this.showMultiplayerEndGame();
                    return; // Stop processing other state updates
                }

                // Determine if it's my turn (needed for timer logic below)
                const currentPlayerId = this.gameState.currentPlayer;
                const isMyTurn = currentPlayerId === this.playerId;

                // Sync timer
                if (this.gameState.timer !== undefined) {
                    // Clear existing local timer if round is not active
                    if (!this.gameState.roundActive) {
                        if (this.localTimer) {
                            clearInterval(this.localTimer);
                            this.localTimer = null;
                        }
                        // Reset display to full duration
                        this.game.timeLeft = this.gameState.timer;
                        const timerEl = document.getElementById('timer-display');
                        if (timerEl) {
                            timerEl.textContent = this.gameState.timer;
                            timerEl.classList.remove('pulse-timer');
                        }
                    } else {
                        // Round IS active. Start local timer if not running
                        if (!this.localTimer && this.gameState.roundStartTime) {
                            this.localTimer = setInterval(() => {
                                const now = Date.now() + (this.serverTimeOffset || 0);
                                const elapsed = (now - this.gameState.roundStartTime) / 1000;
                                const remaining = Math.max(0, Math.ceil(this.gameState.timer - elapsed));

                                this.game.timeLeft = remaining;

                                const timerEl = document.getElementById('timer-display');
                                if (timerEl) {
                                    timerEl.textContent = remaining;
                                    if (remaining <= 10) {
                                        timerEl.classList.add('pulse-timer');
                                    } else {
                                        timerEl.classList.remove('pulse-timer');
                                    }
                                }

                                // Check for end of round
                                if (remaining <= 0 && this.gameState.roundActive) {
                                    // Prevent multiple triggers
                                    if (this.endingRound) return;

                                    const currentPlayerId = this.gameState.currentPlayer;
                                    if (currentPlayerId === this.playerId) {
                                        this.endRound(false);
                                    }
                                }
                            }, 100);
                        }
                    }
                }

                // Sync current card
                const isTeamMode = !!this.gameState.teams;
                const myTeam = this.players[this.playerId]?.team;
                const currentPlayerTeam = this.players[currentPlayerId]?.team;
                const isOpposingTeam = isTeamMode && myTeam && currentPlayerTeam && myTeam !== currentPlayerTeam;
                const shouldSee = isMyTurn || (isTeamMode && isOpposingTeam);

                // Handle Finish Game prompt (New Conditional Leave Logic)
                if (this.gameState.promptFinish || this.gameState.forcedFinish) {
                    const modal = document.getElementById('modal-finish-game-prompt');
                    const msgEl = document.getElementById('finish-game-msg');
                    const continueBtn = document.getElementById('continue-anyway-btn');

                    if (modal) {
                        modal.classList.remove('hidden');
                        if (this.gameState.forcedFinish) {
                            if (msgEl) msgEl.textContent = "Too many players have left. The game must end to keep it fair for everyone.";
                            if (continueBtn) continueBtn.classList.add('hidden');
                        } else {
                            if (msgEl) msgEl.textContent = "A player left and the teams are now unbalanced. Would you like to finish and see the scores?";
                            if (continueBtn) continueBtn.classList.remove('hidden');
                        }
                    }
                }

                if (this.gameState.currentCard && this.gameState.roundActive) {
                    this.game.currentCard = this.gameState.currentCard;
                    if (shouldSee) {
                        this.game.displayCard(this.gameState.currentCard);
                    } else {
                        // Explicitly redact if not allowed to see
                        const wordEl = document.getElementById('word-to-guess');
                        const tabooEl = document.getElementById('taboo-words');
                        if (wordEl) wordEl.textContent = '???';
                        if (tabooEl) tabooEl.innerHTML = '<li class="text-slate-300 italic">Hidden from guesser</li>';
                    }
                } else if (!this.gameState.roundActive) {
                    // Clear card display if round not active
                    const wordEl = document.getElementById('word-to-guess');
                    const tabooEl = document.getElementById('taboo-words');
                    if (wordEl) wordEl.textContent = '...';
                    if (tabooEl) tabooEl.innerHTML = '';

                    // Hide buzzer modal if round ended
                    const modal = document.getElementById('modal-end-turn');
                    if (modal) modal.classList.add('hidden');
                }

                // Visual feedback for timer in lobby
                if (this.gameState.status === 'lobby') {
                    if (this.gameState.timer !== undefined) {
                        const standardBtn = document.getElementById('lobby-timer-standard');
                        const beginnerBtn = document.getElementById('lobby-timer-beginner');
                        if (standardBtn && beginnerBtn) {
                            if (this.gameState.timer === 60) {
                                standardBtn.className = "flex-1 py-3 rounded-xl border-2 border-primary bg-primary-light text-primary font-bold text-sm transition-all";
                                beginnerBtn.className = "flex-1 py-3 rounded-xl border-2 border-slate-100 bg-white text-slate-400 font-bold text-sm transition-all";
                            } else {
                                beginnerBtn.className = "flex-1 py-3 rounded-xl border-2 border-primary bg-primary-light text-primary font-bold text-sm transition-all";
                                standardBtn.className = "flex-1 py-3 rounded-xl border-2 border-slate-100 bg-white text-slate-400 font-bold text-sm transition-all";
                            }
                        }
                    }

                    // Visual feedback for Language in Lobby
                    if (this.gameState.language) {
                        ['fr', 'en'].forEach(l => {
                            const btn = document.getElementById(`lobby-lang-${l}`);
                            if (btn) {
                                if (l === this.gameState.language) {
                                    btn.classList.add('border-primary', 'bg-primary-light', 'selected');
                                    btn.classList.remove('border-slate-100', 'bg-white');
                                } else {
                                    btn.classList.remove('border-primary', 'bg-primary-light', 'selected');
                                    btn.classList.add('border-slate-100', 'bg-white');
                                }
                            }
                        });
                    }
                }
            }

            showBuzzModal(buzzData) {
                // Show modal asking if they got it correct
                const modal = document.getElementById('modal-end-turn');
                const textEl = document.getElementById('buzz-modal-text');
                const hintEl = document.getElementById('last-word-hint');

                if (textEl) {
                    // Update: addressing player as 'you' for a more direct experience
                    textEl.innerHTML = `Did you get <span id="last-word-hint" class="font-bold text-primary"></span> correctly?`;
                }

                // Re-fetch hintEl as it might have been replaced by innerHTML
                const newHintEl = document.getElementById('last-word-hint');
                if (newHintEl && this.game.currentCard) {
                    newHintEl.textContent = `"${this.game.currentCard.word}"`;
                }
                if (modal) {
                    modal.classList.remove('hidden');
                }
            }

            updateGameUI() {
                if (!this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                const isMyTurn = currentPlayerId === this.playerId;
                const isTeamMode = !!this.gameState.teams;
                const roundActive = this.gameState.roundActive;

                // Show/hide Leave Game button
                const leaveBtn = document.getElementById('leave-game-btn');
                if (leaveBtn) {
                    leaveBtn.classList.remove('hidden');
                }

                // Update HUD score with player's total score
                const scoreEl = document.getElementById('score-display');
                if (scoreEl && this.players[this.playerId]) {
                    scoreEl.textContent = this.players[this.playerId].score || 0;
                }

                // Persistent "Your Team" badge
                const yourTeamBadge = document.getElementById('your-team-badge');
                if (yourTeamBadge && this.players[this.playerId]) {
                    const myTeam = this.players[this.playerId].team;
                    if (myTeam && isTeamMode) {
                        yourTeamBadge.classList.remove('hidden');
                        yourTeamBadge.textContent = `Your Team: ${myTeam}`;
                        yourTeamBadge.className = `your-team-pill ${myTeam === 'A' ? 'team-a' : 'team-b'}`;
                    } else {
                        yourTeamBadge.classList.add('hidden');
                    }
                }

                // Show/hide multiplayer UI elements
                const turnIndicator = document.getElementById('multiplayer-turn-indicator');
                const roleBadge = document.getElementById('turn-role-badge');
                const startRoundBtn = document.getElementById('multiplayer-start-round');
                const waitingMsg = document.getElementById('multiplayer-waiting');
                const playerList = document.getElementById('multiplayer-player-list');
                const buzzerContainer = document.getElementById('multiplayer-buzzer-container');

                // UI Buttons
                const skipBtn = document.getElementById('btn-skip');
                const buzzedBtn = document.getElementById('btn-buzzed');
                const correctBtn = document.getElementById('btn-correct');

                const currentPlayer = this.players[currentPlayerId];
                const currentPlayerName = currentPlayer?.name || 'Unknown';
                const activeTeam = currentPlayer?.team;

                // Apply team theme to game board
                const mainBoard = document.querySelector('main > div#screen-game');
                if (mainBoard) {
                    mainBoard.classList.remove('team-a-theme', 'team-b-theme');
                    if (isTeamMode && activeTeam) {
                        mainBoard.classList.add(activeTeam === 'A' ? 'team-a-theme' : 'team-b-theme');
                    }
                }

                if (turnIndicator) turnIndicator.classList.remove('hidden');
                if (playerList) playerList.classList.remove('hidden');

                // Apply team theme to indicator
                if (turnIndicator) {
                    turnIndicator.classList.remove('team-a', 'team-b', 'bg-slate-50', 'border-slate-200');
                    if (isTeamMode && activeTeam) {
                        turnIndicator.classList.add(activeTeam === 'A' ? 'team-a' : 'team-b');
                    } else {
                        turnIndicator.classList.add('bg-slate-50', 'border-slate-200');
                    }
                }

                const myTeam = this.players[this.playerId]?.team;
                const isSameTeam = isTeamMode && myTeam && activeTeam && myTeam === activeTeam;
                const isOpposingTeam = isTeamMode && myTeam && activeTeam && myTeam !== activeTeam;

                if (roleBadge) {
                    roleBadge.classList.remove('hidden', 'bg-pink-600', 'bg-blue-300', 'bg-slate-800', 'text-white');
                    if (isTeamMode) {
                        roleBadge.classList.remove('hidden');
                        if (isMyTurn) {
                            roleBadge.textContent = 'Describer View';
                            roleBadge.classList.add('bg-primary', 'text-white');
                        } else if (isSameTeam) {
                            roleBadge.textContent = 'Guesser View';
                            roleBadge.classList.add('bg-primary-light', 'text-primary');
                        } else if (isOpposingTeam) {
                            roleBadge.textContent = 'Buzzer Duty';
                            roleBadge.classList.add('bg-slate-800', 'text-white');
                        }
                    } else {
                        roleBadge.classList.add('hidden');
                    }
                }

                if (isMyTurn) {
                    if (roundActive) {
                        if (startRoundBtn) startRoundBtn.classList.add('hidden');
                        if (waitingMsg) waitingMsg.classList.add('hidden');
                    } else {
                        if (startRoundBtn) startRoundBtn.classList.remove('hidden');
                        if (waitingMsg) waitingMsg.classList.add('hidden');
                    }
                    if (turnIndicator) {
                        turnIndicator.querySelector('#turn-indicator-text').textContent = isTeamMode ? `Team ${activeTeam} is up!` : 'Your Turn!';
                        turnIndicator.querySelector('#turn-indicator-subtext').textContent = roundActive ? 'Describe the word!' : 'Start your round when ready';
                    }
                } else {
                    if (startRoundBtn) startRoundBtn.classList.add('hidden');

                    // Only show waiting message if round is NOT active (i.e. waiting to start)
                    if (waitingMsg) {
                        if (roundActive) {
                            waitingMsg.classList.add('hidden');
                        } else {
                            waitingMsg.classList.remove('hidden');
                            waitingMsg.querySelector('#waiting-text').textContent = `Waiting for ${currentPlayerName} to start their round...`;
                        }
                    }

                    if (turnIndicator) {
                        turnIndicator.querySelector('#turn-indicator-text').textContent = isTeamMode ? `Team ${activeTeam} is up!` : `${currentPlayerName}'s Turn`;
                        if (isTeamMode) {
                            if (isOpposingTeam) {
                                turnIndicator.querySelector('#turn-indicator-subtext').textContent = `${currentPlayerName} is describing. Buzz if you hear a taboo word!`;
                            } else {
                                turnIndicator.querySelector('#turn-indicator-subtext').textContent = `${currentPlayerName} is describing. Guess the word!`;
                            }
                        } else {
                            turnIndicator.querySelector('#turn-indicator-subtext').textContent = `${currentPlayerName} is describing. Guess the word!`;
                        }
                    }
                }

                // Show/hide GLOBAL buzzer based on role
                const globalBuzzer = document.getElementById('global-buzzer');
                if (globalBuzzer) {
                    const shouldShowBuzzer = roundActive && isOpposingTeam;
                    if (shouldShowBuzzer) {
                        globalBuzzer.classList.remove('hidden');
                    } else {
                        globalBuzzer.classList.add('hidden');
                    }
                }

                if (isMyTurn && roundActive) {
                    // Active player during their round: show skip, buzzed, and correct buttons
                    if (skipBtn) skipBtn.classList.remove('hidden');
                    if (buzzedBtn) buzzedBtn.classList.remove('hidden');
                    if (correctBtn) correctBtn.classList.remove('hidden');
                    if (buzzerContainer) buzzerContainer.classList.add('hidden');
                } else if (!isMyTurn && roundActive) {
                    // Other players during active round
                    if (isOpposingTeam) {
                        // Opposing team: show instructions, hide skip/correct/buzzed
                        if (skipBtn) skipBtn.classList.add('hidden');
                        if (buzzedBtn) buzzedBtn.classList.add('hidden');
                        if (correctBtn) correctBtn.classList.add('hidden');
                        if (buzzerContainer) buzzerContainer.classList.remove('hidden');
                    } else if (isSameTeam || !isTeamMode) {
                        // Same team (guessing) or FFA (no buzzer as per request): hide everything except timer
                        if (skipBtn) skipBtn.classList.add('hidden');
                        if (buzzedBtn) buzzedBtn.classList.add('hidden');
                        if (correctBtn) correctBtn.classList.add('hidden');
                        if (buzzerContainer) buzzerContainer.classList.add('hidden');
                    }
                } else {
                    // Round not active
                    if (skipBtn) skipBtn.classList.add('hidden');
                    if (buzzedBtn) buzzedBtn.classList.add('hidden');
                    if (correctBtn) correctBtn.classList.add('hidden');
                    if (buzzerContainer) buzzerContainer.classList.add('hidden');
                }

                // Sync skip button state with limit
                if (skipBtn && isMyTurn && roundActive) {
                    skipBtn.textContent = `Skip (${this.game.skips}/1)`;
                    skipBtn.disabled = this.game.skips <= 0;
                }

                // Show card only to active player and opposing team
                const cardContainer = document.getElementById('card-container');
                if (cardContainer) {
                    const shouldSee = roundActive && (isMyTurn || (isTeamMode && isOpposingTeam));
                    if (shouldSee) {
                        cardContainer.classList.remove('hidden');
                    } else {
                        cardContainer.classList.add('hidden');
                    }
                }
            }

            showMultiplayerEndGame() {
                this.game.showScreen('multiplayer-endgame');

                // Hide unbalanced/forced finish modal if it was showing
                const finishModal = document.getElementById('modal-finish-game-prompt');
                if (finishModal) finishModal.classList.add('hidden');

                // Determine winner(s)
                const playerArray = Object.entries(this.players).map(([id, data]) => ({
                    id,
                    ...data
                }));

                // Sort by score descending
                playerArray.sort((a, b) => (b.score || 0) - (a.score || 0));

                const isTeamMode = !!this.gameState.teams;
                let winners = [];
                let winnerText = "";
                let winnerSubtext = "";
                let winnerEmoji = "üèÜ";

                if (isTeamMode) {
                    // Team Based Scoring
                    const teamA = playerArray.filter(p => p.team === 'A');
                    const teamB = playerArray.filter(p => p.team === 'B');
                    const scoreA = teamA.reduce((sum, p) => sum + (p.score || 0), 0);
                    const scoreB = teamB.reduce((sum, p) => sum + (p.score || 0), 0);

                    // Update UI cards
                    const teamContainer = document.getElementById('team-scores-container');
                    if (teamContainer) teamContainer.classList.remove('hidden');

                    const scoreAEl = document.getElementById('team-a-total-pts');
                    const scoreBEl = document.getElementById('team-b-total-pts');
                    if (scoreAEl) scoreAEl.textContent = scoreA;
                    if (scoreBEl) scoreBEl.textContent = scoreB;

                    const cardA = document.getElementById('team-a-score-card');
                    const cardB = document.getElementById('team-b-score-card');
                    if (cardA) cardA.classList.remove('team-winner-glow');
                    if (cardB) cardB.classList.remove('team-winner-glow-b');

                    if (scoreA > scoreB) {
                        winnerText = "Team A Wins!";
                        winnerSubtext = `Team Scored ${scoreA} Points!`;
                        if (cardA) cardA.classList.add('team-winner-glow');
                        winners = teamA;
                    } else if (scoreB > scoreA) {
                        winnerText = "Team B Wins!";
                        winnerSubtext = `Team Scored ${scoreB} Points!`;
                        if (cardB) cardB.classList.add('team-winner-glow-b');
                        winners = teamB;
                    } else {
                        winnerText = "It's a Team Draw!";
                        winnerSubtext = `Both teams scored ${scoreA} points!`;
                        winners = playerArray;
                    }
                } else {
                    // FFA Scoring
                    const highestScore = playerArray[0]?.score || 0;
                    winners = playerArray.filter(p => p.score === highestScore);
                    const winnerNames = winners.map(w => w.name).join(' & ');

                    if (winners.length > 1) {
                        winnerText = "Draw!";
                        winnerSubtext = `${winnerNames} both scored ${highestScore} points!`;
                    } else {
                        winnerText = `${winners[0]?.name} Wins!`;
                        winnerSubtext = `A stunning performance with ${highestScore} points!`;
                    }

                    const teamContainer = document.getElementById('team-scores-container');
                    if (teamContainer) teamContainer.classList.add('hidden');
                }

                const isWinner = winners.some(w => w.id === this.playerId);
                if (!isWinner) winnerEmoji = "üëè";

                // Update winner indicator
                const emojiEl = document.getElementById('winner-emoji');
                const titleEl = document.getElementById('winner-title');
                const subtitleEl = document.getElementById('winner-subtitle');
                const indicatorEl = document.getElementById('winner-indicator');

                if (emojiEl) emojiEl.textContent = winnerEmoji;
                if (titleEl) titleEl.textContent = winnerText;
                if (subtitleEl) subtitleEl.textContent = winnerSubtext;
                if (indicatorEl) {
                    indicatorEl.classList.remove('winner-animation', 'loser-animation');
                    if (isWinner) {
                        indicatorEl.classList.add('winner-animation');
                    } else {
                        indicatorEl.classList.add('loser-animation');
                    }
                }

                // Save game to history
                this.storage.addGameToHistory({
                    roomCode: this.roomCode,
                    score: this.players[this.playerId]?.score || 0,
                    mode: isTeamMode ? 'Team' : 'FFA',
                    winnerText: winnerText,
                    isWinner: isWinner
                });

                // Display final scores
                const scoresListEl = document.getElementById('final-scores-list');
                if (scoresListEl) {
                    scoresListEl.innerHTML = '';
                    playerArray.forEach((player, index) => {
                        const div = document.createElement('div');
                        div.className = `flex justify-between items-center p-3 rounded-xl ${player.id === this.playerId ? 'bg-slate-50 border-2 border-slate-200' : 'bg-white'}`;

                        const teamIndicator = isTeamMode ?
                            `<span class="text-[9px] font-black uppercase px-2 py-0.5 rounded-full ${player.team === 'A' ? 'team-a' : 'team-b'} ml-2">Team ${player.team}</span>` : '';

                        div.innerHTML = `
                            <div class="flex items-center">
                                <span class="text-xs font-black text-slate-400 mr-3">${index + 1}</span>
                                <span class="font-bold text-slate-800">${player.name}${player.id === this.playerId ? ' (You)' : ''}</span>
                                ${teamIndicator}
                            </div>
                            <span class="font-black text-slate-800">${player.score || 0}</span>
                        `;
                        scoresListEl.appendChild(div);
                    });
                }

                // Display my words
                const myWordsListEl = document.getElementById('my-words-list');
                if (myWordsListEl) {
                    myWordsListEl.innerHTML = '';
                    if (this.game.wordLog.length === 0) {
                        myWordsListEl.innerHTML = '<p class="text-xs text-slate-400 italic">You didn\'t describe any words this game.</p>';
                    } else {
                        this.game.wordLog.forEach(item => {
                            const div = document.createElement('div');
                            div.className = "flex justify-between items-center p-3 border-b border-slate-50 last:border-0";
                            const url = this.game.getRefUrl(item.word, item.type);
                            const statusColors = { correct: 'bg-green-100 text-green-700', skipped: 'bg-yellow-100 text-yellow-700', timeout: 'bg-red-100 text-red-700' };
                            const statusLabels = { correct: '‚úì', skipped: 'Skip', timeout: 'Time' };
                            div.innerHTML = `
                                <div class="flex flex-col">
                                    <a href="${url}" target="_blank" class="word-link font-bold text-slate-700">
                                        ${item.word} <span class="text-[8px] opacity-30">‚Üó</span>
                                    </a>
                                    <span class="text-[9px] text-slate-400 uppercase font-bold">${item.level}</span>
                                </div>
                                <span class="text-[9px] font-black uppercase px-2 py-1 rounded-md ${statusColors[item.status]}">${statusLabels[item.status]}</span>
                            `;
                            myWordsListEl.appendChild(div);
                        });
                    }
                }
            }

            async validateRoomState() {
                if (!this.isHost || !this.gameState || this.gameState.status !== 'playing') return;

                const initialCount = this.gameState.initialPlayerCount || 2;
                const turnOrder = this.gameState.turnOrder || [];
                const currentPlayers = Object.keys(this.players);

                // 1. Sync Turn Order: Remove any players who are no longer in the room
                const newTurnOrder = turnOrder.filter(id => this.players[id]);

                if (newTurnOrder.length !== turnOrder.length) {
                    console.log("Syncing turn order after departure...");
                    await this.roomRef.child('gameState/turnOrder').set(newTurnOrder);

                    // If the active player is gone, skip their turn
                    if (!this.players[this.gameState.currentPlayer]) {
                        console.log("Current player left, skipping ghost turn...");
                        await this.forceSkipGhostTurn(newTurnOrder);
                    }
                }

                // 2. Check Balance Thresholds (1vN)
                const playerCount = currentPlayers.length;
                let shouldFinish = false;

                if (initialCount === 4 && playerCount === 3) {
                    // Start 4 -> 3 left (2v1) -> Mandatory end
                    shouldFinish = true;
                } else if (initialCount >= 5) {
                    const teamA = currentPlayers.filter(id => this.players[id].team === 'A');
                    const teamB = currentPlayers.filter(id => this.players[id].team === 'B');

                    if (teamA.length <= 1 || teamB.length <= 1) {
                        shouldFinish = true;
                    }
                } else if (initialCount < 4 && playerCount < 2) {
                    // FFA mode needs at least 2
                    shouldFinish = true;
                }

                if (shouldFinish && !this.gameState.forcedFinish && !this.gameState.promptFinish) {
                    console.log("Teams unbalanced, forcing game end.");
                    await this.roomRef.child('gameState/forcedFinish').set(true);
                }
            }

            // Keep this for when someone explicitly leaves while current player
            async handlePlayerDeparture(removedPlayerId) {
                // Logic mostly moved to validateRoomState for robustness
                if (this.isHost) await this.validateRoomState();
            }

            async forceSkipGhostTurn(newTurnOrder) {
                if (newTurnOrder.length === 0) {
                    await this.endGame();
                    return;
                }
                const currentIndex = this.gameState.currentTurnIndex || 0;
                const nextIndex = currentIndex % newTurnOrder.length;
                const nextPlayer = newTurnOrder[nextIndex];

                await this.roomRef.child('gameState').update({
                    currentPlayer: nextPlayer,
                    currentCard: null,
                    roundActive: false,
                    timer: this.gameState.timer,
                    currentTurnIndex: nextIndex
                });
            }

            async leaveRoom() {
                try {
                    if (this.roomRef && this.playerId) {
                        // Just remove the individual player node
                        await this.roomRef.child(`players/${this.playerId}`).remove();
                    }
                } catch (error) {
                    console.error('Error leaving room:', error);
                } finally {
                    this.storage.clearRoomCode();
                    this.cleanup();
                    // Using location.reload() to guarantee full fresh state and main menu return
                    location.reload();
                }
            }

            cleanup() {
                if (this.roomRef) {
                    this.roomRef.off();
                }
                this.roomRef = null;
                this.roomCode = null;
                this.isHost = false;
                this.players = {};
                this.gameState = null;
                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }
                if (this.localTimer) {
                    clearInterval(this.localTimer);
                    this.localTimer = null;
                }
                if (this.hostTimer) {
                    clearInterval(this.hostTimer);
                    this.hostTimer = null;
                }
            }

            copyRoomCode() {
                if (this.roomCode) {
                    navigator.clipboard.writeText(this.roomCode).then(() => {
                        const btn = document.getElementById('btn-copy-code');
                        if (btn) {
                            const originalText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                            }, 2000);
                        }
                    });
                }
            }
        }

        class TabooPro {
            constructor() {
                this.db = { fr: [], en: [] };
                this.activeLanguage = null; // 'fr' or 'en'
                this.playedIds = new Set();
                this.selectedLevel = null;
                this.score = 0;
                this.roundScore = 0;
                this.roundNumber = 1;
                this.roundHistory = [];
                this.wordLog = [];

                this.timeLeft = 60;
                this.skips = 1;
                this.timer = null;
                this.currentCard = null;
                this.audio = null;
                this.levels = ['A1', 'A2', 'B1', 'B2'];

                this.multiplayerMode = false;
                this.storage = new StorageManager();
                this.multiplayer = new MultiplayerManager(this);

                this.initApp();
            }

            async initApp() {
                // Platform specific visuals (Windows Emojis)
                this.updatePlatformVisuals();

                // Load saved language
                const savedLang = localStorage.getItem('taboo_lang');
                if (savedLang) {
                    this.setLanguage(savedLang);
                }

                await this.fetchData();
                if (this.multiplayer) {
                    this.multiplayer.tryAutoRejoin();
                }
            }

            updatePlatformVisuals() {
                const isWindows = navigator.userAgent.indexOf('Windows') !== -1;
                if (isWindows) {
                    // Start screen logo (initial state is France)
                    const mainLogo = document.getElementById('main-logo-emoji');
                    if (mainLogo && mainLogo.textContent.trim() === 'üá´üá∑') {
                        mainLogo.textContent = 'ü•ñ';
                    }

                    // Update all English buttons to Tea
                    document.querySelectorAll('.emoji-en').forEach(el => el.textContent = 'üçµ');
                    // Update all French buttons to Baguette
                    document.querySelectorAll('.emoji-fr').forEach(el => el.textContent = 'ü•ñ');
                }
            }

            async fetchData() {
                try {
                    const [resFr, resEn] = await Promise.all([
                        fetch(REMOTE_URL_FR),
                        fetch(REMOTE_URL_EN)
                    ]);

                    const textFr = await resFr.text();
                    const textEn = await resEn.text();

                    this.loadData(textFr, 'fr');
                    this.loadData(textEn, 'en');
                } catch (e) {
                    console.error("Error loading data:", e);
                    const el = document.getElementById('total-card-count');
                    if (el) el.textContent = 'Error loading list';
                }
            }

            loadData(csvText, lang) {
                const lines = csvText.trim().split('\n');
                const results = [];
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 8) continue;
                    const word = cols[0].trim();
                    const level = cols[1].trim();
                    results.push({
                        id: word + '|' + level,
                        word,
                        level: level,
                        levelIdx: this.levels.indexOf(level),
                        type: cols[2].trim(),
                        taboo: [cols[3], cols[4], cols[5], cols[6], cols[7]].map(s => s.trim())
                    });
                }
                this.db[lang] = results;

                // Initialize played IDs if not already done
                if (!this.playedIds) {
                    const stored = [];
                    try {
                        const raw = localStorage.getItem('taboo_played');
                        if (raw) stored.push(...JSON.parse(raw));
                    } catch (_) { }
                    this.playedIds = new Set(stored);
                }

                this.updateStartUI();
            }

            getPool(level) {
                if (!level || !this.activeLanguage || !this.db[this.activeLanguage]) return [];
                const dataset = this.db[this.activeLanguage];
                const maxIdx = this.levels.indexOf(level);
                const playedSource = this.multiplayerMode ? this.multiplayer.sessionPlayedIds : this.playedIds;
                return dataset.filter(c => c.levelIdx <= maxIdx && !playedSource.has(c.id));
            }

            addPlayed(id) {
                if (!id) return;
                if (this.multiplayerMode) return; // Session history is handled in Firebase
                this.playedIds.add(id);
                try {
                    localStorage.setItem('taboo_played', JSON.stringify([...this.playedIds]));
                } catch (_) { }
            }

            resetAllCards() {
                this.playedIds.clear();
                try { localStorage.removeItem('taboo_played'); } catch (_) { }
                this.updateStartUI();
            }

            updateStartUI() {
                const el = document.getElementById('total-card-count');
                if (!el) return;

                const startBtn = document.getElementById('btn-start-round');
                if (!startBtn) return;

                if (!this.selectedLevel || !this.activeLanguage) {
                    const frCount = this.db.fr ? this.db.fr.length : 0;
                    const enCount = this.db.en ? this.db.en.length : 0;
                    const total = frCount + enCount;
                    el.textContent = `${total} cards loaded ¬∑ Select Language & Level`;
                    startBtn.disabled = true;
                    startBtn.className = "btn-3d w-full bg-slate-200 text-slate-400 py-4 rounded-2xl font-black text-xl shadow-lg";
                    startBtn.textContent = "Select a Level";
                    return;
                }

                const pool = this.getPool(this.selectedLevel);
                el.textContent = `${pool.length} cards in stack`;

                if (pool.length === 0) {
                    startBtn.disabled = true;
                    startBtn.className = "btn-3d w-full bg-slate-200 text-slate-400 py-4 rounded-2xl font-black text-xl shadow-lg transition-all";
                    startBtn.textContent = "No cards left - Reset to play";
                } else {
                    startBtn.disabled = false;
                    startBtn.className = "btn-3d w-full bg-pink-500 text-white py-4 rounded-2xl font-black text-xl shadow-lg transition-all transform hover:scale-[1.02] active:scale-[0.98]";
                    startBtn.textContent = `Start Round (${pool.length} in stack)`;
                }
            }

            updateStackDisplay() {
                const pool = this.getPool(this.selectedLevel);
                const el = document.getElementById('stack-display');
                if (el) el.textContent = pool.length;
            }

            initAudio() {
                if (!this.audio) this.audio = new (window.AudioContext || window.webkitAudioContext)();
            }

            playObnoxiousBuzzer() {
                this.initAudio();
                document.getElementById('main-body').classList.add('buzz-flash');
                setTimeout(() => document.getElementById('main-body').classList.remove('buzz-flash'), 300);

                const duration = 1.5;
                const frequencies = [150, 165, 190];

                frequencies.forEach(freq => {
                    const osc = this.audio.createOscillator();
                    const gain = this.audio.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(freq, this.audio.currentTime);

                    gain.gain.setValueAtTime(0.08, this.audio.currentTime);
                    gain.gain.linearRampToValueAtTime(0.08, this.audio.currentTime + 1.0);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audio.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.audio.destination);
                    osc.start();
                    osc.stop(this.audio.currentTime + duration);
                });
            }

            getRefUrl(word, type) {
                const normalizedType = (type || "").trim().toLowerCase();
                const wiktionaryTypes = ['noun', 'adj', 'verb', 'adj/noun', 'noun/adj', 'nom', 'verbe', 'adjectif'];
                const isWiktionary = wiktionaryTypes.includes(normalizedType);

                if (isWiktionary) {
                    // Wiktionary needs lowercase for general words to resolve correctly
                    const lowercaseWord = word.toLowerCase().replace(/\s+/g, '_');
                    const langDomain = this.activeLanguage === 'en' ? 'en' : 'fr';
                    return `https://${langDomain}.wiktionary.org/wiki/${encodeURIComponent(lowercaseWord)}`;
                }

                // Wikipedia generally handles capitalized titles better
                const encodedWord = encodeURIComponent(word.replace(/\s+/g, '_'));
                if (this.activeLanguage === 'en') {
                    return `https://en.wikipedia.org/wiki/${encodedWord}`;
                }
                return `https://fr.wikipedia.org/wiki/${encodedWord}`;
            }

            setLanguage(lang) {
                this.activeLanguage = lang;
                localStorage.setItem('taboo_lang', lang);

                // Toggle theme
                if (lang === 'en') {
                    document.body.classList.add('theme-english');
                } else {
                    document.body.classList.remove('theme-english');
                }

                // Update Main Logo based on OS and Language
                const logoEl = document.getElementById('main-logo-emoji');
                if (logoEl) {
                    const isWindows = navigator.userAgent.indexOf('Windows') !== -1;
                    if (lang === 'en') {
                        // English: Tea (Win) or Flag (Others)
                        logoEl.textContent = isWindows ? 'üçµ' : 'üá¨üáß';
                    } else {
                        // French: Baguette (Win) or Flag (Others)
                        logoEl.textContent = isWindows ? 'ü•ñ' : 'üá´üá∑';
                    }
                }

                // Update UI selection
                ['fr', 'en'].forEach(l => {
                    const btn = document.getElementById(`lang-${l}`);
                    if (btn) {
                        if (l === lang) {
                            btn.classList.add('border-primary', 'bg-primary-light', 'selected');
                            btn.classList.remove('border-slate-100', 'bg-white');
                        } else {
                            btn.classList.remove('border-primary', 'bg-primary-light', 'selected');
                            btn.classList.add('border-slate-100', 'bg-white');
                        }
                    }
                });

                // Enable level buttons
                document.querySelectorAll('.level-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                });

                // Reset level selection if language changes (to force re-selection or at least re-validation)
                // Actually, let's keep the level if it was already selected, but update the start UI
                this.updateStartUI();

                // If in multiplayer lobby, we should ideally sync this, but for now just local
            }

            setLevel(lvl, btn) {
                if (!this.activeLanguage) {
                    // Should be disabled, but just in case
                    alert("Please select a language first.");
                    return;
                }
                this.selectedLevel = lvl;
                document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.updateStartUI();
            }

            setTab(tab) {
                this.activeTab = tab;
                const localTab = document.getElementById('tab-local');
                const onlineTab = document.getElementById('tab-online');
                const localContent = document.getElementById('content-local');
                const onlineContent = document.getElementById('content-online');

                if (tab === 'local') {
                    localTab.className = "flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 bg-white text-slate-800 shadow-sm";
                    onlineTab.className = "flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 text-slate-400";
                    localContent.classList.remove('hidden');
                    onlineContent.classList.add('hidden');
                } else {
                    onlineTab.className = "flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 bg-white text-slate-800 shadow-sm";
                    localTab.className = "flex-1 py-3 rounded-xl font-black text-sm transition-all flex items-center justify-center gap-2 text-slate-400";
                    onlineContent.classList.remove('hidden');
                    localContent.classList.add('hidden');
                }
            }

            setTimerMode(duration, btn) {
                this.timeLeft = duration;
                this.timerDuration = duration;

                // Update UI state
                document.getElementById('timer-standard').className = 'flex-1 py-3 rounded-xl border-2 transition-all ' +
                    (duration === 60 ? 'border-primary bg-primary-light text-primary font-bold text-sm' : 'border-slate-100 bg-white text-slate-400 font-bold text-sm');
                document.getElementById('timer-beginner').className = 'flex-1 py-3 rounded-xl border-2 transition-all ' +
                    (duration === 120 ? 'border-primary bg-primary-light text-primary font-bold text-sm' : 'border-slate-100 bg-white text-slate-400 font-bold text-sm');

                // Update HUD immediately
                const timerEl = document.getElementById('timer-display');
                if (timerEl) timerEl.textContent = duration;
            }

            startRound() {
                if (this.multiplayerMode) {
                    // Multiplayer rounds are started by individual players
                    return;
                }

                // Single-player logic
                const pool = this.getPool(this.selectedLevel);
                if (pool.length === 0) {
                    this.showScreen('start');
                    this.updateStartUI();
                    return;
                }
                this.initAudio();
                this.roundScore = 0;
                this.timeLeft = this.timerDuration || 60;
                this.skips = 1;
                this.updateStackDisplay();
                this.nextCard(false);
                this.showScreen('game');

                this.timer = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timer-display').textContent = this.timeLeft;
                    if (this.timeLeft <= 10) document.getElementById('timer-display').classList.add('pulse-timer');
                    if (this.timeLeft <= 0) {
                        clearInterval(this.timer);
                        this.playObnoxiousBuzzer();
                        document.getElementById('last-word-hint').textContent = `"${this.currentCard.word}"`;
                        document.getElementById('modal-end-turn').classList.remove('hidden');
                    }
                }, 1000);
            }

            nextCard(scored, skipAction = false) {
                if (this.currentCard) {
                    const status = scored ? 'correct' : (skipAction ? 'skipped' : 'timeout');
                    this.wordLog.push({
                        word: this.currentCard.word,
                        type: this.currentCard.type,
                        level: this.currentCard.level,
                        status: status
                    });
                    this.storage.updateLastWordStatus(status);
                    this.addPlayed(this.currentCard.id);
                }

                if (scored) {
                    this.roundScore++;
                    this.score++;
                }

                const pool = this.getPool(this.selectedLevel);
                this.updateStackDisplay();

                if (pool.length === 0) {
                    this.finishRound(false, true);
                    return;
                }

                this.currentCard = pool[Math.floor(Math.random() * pool.length)];
                document.getElementById('word-to-guess').textContent = this.currentCard.word;
                document.getElementById('card-level-tag').textContent = `Level ${this.currentCard.level}`;
                const list = document.getElementById('taboo-words');
                list.innerHTML = '';
                this.currentCard.taboo.forEach(t => {
                    const li = document.createElement('li');
                    li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                    li.textContent = t;
                    list.appendChild(li);
                });

                document.getElementById('score-display').textContent = this.score;
                document.getElementById('btn-skip').textContent = `Skip (${this.skips}/1)`;
                document.getElementById('btn-skip').disabled = this.skips <= 0;
            }

            skipCard() {
                if (this.skips > 0) {
                    this.skips--;
                    this.nextCard(false, true);
                }
            }

            async finishRound(lastCorrect, fromExhaust = false) {
                if (this.multiplayerMode) {
                    await this.multiplayer.endRound(lastCorrect);
                    return;
                }

                // Single-player logic
                // Single-player logic
                if (this.currentCard) {
                    const lastLogIdx = this.wordLog.length - 1;
                    const lastLogItem = lastLogIdx >= 0 ? this.wordLog[lastLogIdx] : null;

                    // Prevent duplicate logging
                    if (!lastLogItem || lastLogItem.word !== this.currentCard.word) {
                        this.wordLog.push({
                            word: this.currentCard.word,
                            type: this.currentCard.type,
                            level: this.currentCard.level,
                            status: lastCorrect ? 'correct' : 'timeout'
                        });
                    } else if (lastLogItem.word === this.currentCard.word && lastLogItem.status === 'skipped' && !lastCorrect) {
                        // If it was skipped, DO NOT change it to timeout.
                        // Skipped means skipped.
                    } else if (lastLogItem.word === this.currentCard.word && !lastCorrect) {
                        // Update status to timeout if it was something else? No, usually we just push.
                        // But if we are here, we want to ensure we don't double log.
                    }

                    if (!fromExhaust && (!lastLogItem || lastLogItem.word !== this.currentCard.word)) {
                        this.addPlayed(this.currentCard.id);
                    }
                }

                if (lastCorrect) {
                    this.roundScore++;
                    this.score++;
                }

                clearInterval(this.timer);
                this.roundHistory.push({ round: this.roundNumber, score: this.roundScore });

                document.getElementById('round-score-val').textContent = this.roundScore;
                document.getElementById('summary-title').textContent = `Round ${this.roundNumber} Done!`;
                this.roundNumber++;
                this.currentCard = null;
                this.showScreen('summary');
            }

            continueAnyway() {
                const modal = document.getElementById('modal-finish-game-prompt');
                if (modal) modal.classList.add('hidden');

                // Clear the flag in Firebase so other players don't see it anymore
                if (this.multiplayerMode && this.multiplayer.isHost) {
                    this.multiplayer.roomRef.child('gameState/promptFinish').remove();
                }
            }

            showEndGame() {
                document.getElementById('total-final-score').textContent = this.score;
                document.getElementById('total-rounds-count').textContent = this.roundHistory.length;
                const histList = document.getElementById('round-history-list');
                histList.innerHTML = '';
                this.roundHistory.forEach(h => {
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center bg-slate-50 p-3 rounded-xl";
                    div.innerHTML = `
                        <span class="text-xs font-bold text-slate-500 uppercase">Round ${h.round}</span>
                        <span class="font-black text-slate-800">${h.score} pts</span>
                    `;
                    histList.appendChild(div);
                });
                this.showScreen('endgame');
            }

            showWordReview() {
                document.getElementById('btn-show-review').classList.add('hidden');
                const reviewSection = document.getElementById('review-section');
                reviewSection.classList.remove('hidden');
                const list = document.getElementById('word-review-list');
                list.innerHTML = '';
                if (this.wordLog.length === 0) {
                    list.innerHTML = `<p class="text-xs text-slate-400 italic">No words played this session.</p>`;
                    return;
                }
                this.wordLog.forEach(item => {
                    const statusColors = { correct: 'bg-green-100 text-green-700', skipped: 'bg-yellow-100 text-yellow-700', timeout: 'bg-red-100 text-red-700' };
                    const statusLabels = { correct: 'Correct', skipped: 'Skipped', timeout: 'Buzzed' };
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center p-3 border-b border-slate-50 last:border-0";
                    const url = this.getRefUrl(item.word, item.type);
                    div.innerHTML = `
                        <div class="flex flex-col">
                            <a href="${url}" target="_blank" class="word-link font-black text-slate-700">
                                ${item.word} <span class="text-[8px] opacity-30">‚Üó</span>
                            </a>
                            <span class="text-[9px] text-slate-400 uppercase font-bold">${item.level} ‚Ä¢ ${item.type || 'N/A'}</span>
                        </div>
                        <span class="text-[9px] font-black uppercase px-2 py-1 rounded-md ${statusColors[item.status]}">${statusLabels[item.status]}</span>
                    `;
                    list.appendChild(div);
                });
            }

            showScreen(id) {
                const screens = ['start', 'game', 'summary', 'endgame', 'multiplayer-options', 'join-room', 'lobby', 'multiplayer-endgame'];
                screens.forEach(s => {
                    const el = document.getElementById('screen-' + s);
                    if (el) el.classList.add('hidden');
                });
                const targetEl = document.getElementById('screen-' + id);
                if (targetEl) targetEl.classList.remove('hidden');

                // Buzzer visibility: Default to HIDDEN. MultiplayerManager.updateGameUI will handle showing it if needed.
                const buzzer = document.getElementById('global-buzzer');
                if (buzzer) {
                    buzzer.classList.add('hidden');
                }

                if (id === 'lobby' && this.multiplayer && this.multiplayer.roomCode) {
                    const roomCodeEl = document.getElementById('lobby-room-code');
                    if (roomCodeEl) roomCodeEl.textContent = this.multiplayer.roomCode;
                }

                const hud = document.getElementById('game-hud');
                const leaveBtn = document.getElementById('leave-game-btn');
                const leaveSep = document.getElementById('leave-separator');

                if (hud) {
                    hud.style.opacity = (id === 'game') ? '1' : '0';
                    hud.style.pointerEvents = (id === 'game') ? 'auto' : 'none';
                }

                // Show/hide leave button and separator based on mode and screen
                if (leaveBtn && leaveSep) {
                    if (this.multiplayerMode && id === 'game') {
                        leaveBtn.classList.remove('hidden');
                        leaveSep.classList.remove('hidden');
                    } else {
                        leaveBtn.classList.add('hidden');
                        leaveSep.classList.add('hidden');
                    }
                }
            }

            showHowToPlay() {
                const modal = document.getElementById('modal-how-to-play');
                if (modal) modal.classList.remove('hidden');
            }

            hideHowToPlay() {
                const modal = document.getElementById('modal-how-to-play');
                if (modal) modal.classList.add('hidden');
            }

            // Multiplayer methods
            showMultiplayerOptions() {
                this.setTab('online');
                this.showScreen('start');
            }

            showJoinRoom() {
                this.showScreen('join-room');
            }

            async createRoom() {
                const nameInput = document.getElementById('input-host-name');
                const hostName = nameInput ? nameInput.value.trim() : null;
                const code = await this.multiplayer.createRoom(hostName);
                if (code) {
                    document.getElementById('lobby-room-code').textContent = code;
                    this.showScreen('lobby');
                } else {
                    alert('Failed to create room. Please check Firebase configuration.');
                }
            }

            async joinRoom() {
                const codeInput = document.getElementById('input-room-code');
                const nameInput = document.getElementById('input-player-name');
                const code = codeInput.value.trim().toUpperCase();
                const name = nameInput.value.trim();

                if (!code || code.length !== 4) {
                    alert('Please enter a valid 4-character room code.');
                    return;
                }

                if (!name || name.length === 0) {
                    alert('Please enter your name.');
                    return;
                }

                const success = await this.multiplayer.joinRoom(code, name);
                if (success) {
                    this.multiplayerMode = true;
                    document.getElementById('lobby-room-code').textContent = code;
                    this.showScreen('lobby');
                }
            }

            async leaveRoom() {
                await this.multiplayer.leaveRoom();
            }

            setMultiplayerLevel(level, btn) {
                this.selectedLevel = level;
                document.querySelectorAll('#screen-lobby .level-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const startBtn = document.getElementById('btn-start-game');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.className = "btn-3d w-full bg-green-500 text-white py-4 rounded-2xl text-xl font-black";
                    startBtn.textContent = `Start Game (Level ${level})`;
                }
            }

            setMultiplayerLanguage(lang, btn) {
                if (this.multiplayer.isHost) {
                    this.multiplayer.setLanguage(lang);
                }
            }

            async startMultiplayerGame() {
                if (!this.selectedLevel) {
                    alert('Please select a level first.');
                    return;
                }
                this.multiplayerMode = true;
                await this.multiplayer.startGame(this.selectedLevel);
            }

            async startMultiplayerRound() {
                await this.multiplayer.startRound();
            }

            setMultiplayerTimer(seconds, btn) {
                if (this.multiplayer.isHost) {
                    this.multiplayer.setTimer(seconds);
                }
            }

            returnToMainMenu() {
                // Clear state to prevent auto-rejoin loop
                this.storage.clearRoomCode();
                this.multiplayer.cleanup();
                window.location.href = window.location.origin + window.location.pathname;
            }

            displayCard(card) {
                if (!card) return;

                // Track word in local history if we are the one describing
                const isMultiplayerDescribing = this.multiplayerMode &&
                    this.multiplayer.gameState &&
                    this.multiplayer.gameState.currentPlayer === this.multiplayer.playerId;

                if (!this.multiplayerMode || isMultiplayerDescribing) {
                    this.storage.addDescribedWord({
                        word: card.word,
                        taboo: card.taboo,
                        level: card.level,
                        type: card.type || 'N/A',
                        status: 'current'
                    });
                }

                document.getElementById('word-to-guess').textContent = card.word;
                document.getElementById('card-level-tag').textContent = `Level ${card.level}`;
                const list = document.getElementById('taboo-words');
                if (list) {
                    list.innerHTML = '';
                    card.taboo.forEach(t => {
                        const li = document.createElement('li');
                        li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                        li.textContent = t;
                        list.appendChild(li);
                    });
                }
            }

            async markBuzzed() {
                if (this.multiplayerMode) {
                    await this.multiplayer.markBuzzed();
                }
            }

            async nextCard(scored) {
                if (this.multiplayerMode) {
                    await this.multiplayer.nextCard(scored);
                } else {
                    // Original single-player logic
                    if (this.currentCard) {
                        this.wordLog.push({
                            word: this.currentCard.word,
                            type: this.currentCard.type,
                            level: this.currentCard.level,
                            status: scored ? 'correct' : 'timeout'
                        });
                        this.addPlayed(this.currentCard.id);
                    }

                    if (scored) {
                        this.roundScore++;
                        this.score++;
                    }

                    const pool = this.getPool(this.selectedLevel);
                    this.updateStackDisplay();

                    if (pool.length === 0) {
                        this.finishRound(false, true);
                        return;
                    }

                    this.currentCard = pool[Math.floor(Math.random() * pool.length)];
                    document.getElementById('word-to-guess').textContent = this.currentCard.word;
                    document.getElementById('card-level-tag').textContent = `Level ${this.currentCard.level}`;
                    const list = document.getElementById('taboo-words');
                    list.innerHTML = '';
                    this.currentCard.taboo.forEach(t => {
                        const li = document.createElement('li');
                        li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                        li.textContent = t;
                        list.appendChild(li);
                    });

                    document.getElementById('score-display').textContent = this.score;
                    document.getElementById('btn-skip').textContent = `Skip (${this.skips}/1)`;
                    document.getElementById('btn-skip').disabled = this.skips <= 0;
                }
            }

            async skipCard() {
                if (this.multiplayerMode) {
                    await this.multiplayer.skipCard();
                } else {
                    // Original single-player logic
                    if (this.skips > 0) {
                        this.skips--;
                        this.nextCard(false, true);
                    }
                }
            }

            copyRoomCode() {
                this.multiplayer.copyRoomCode();
            }

            handleBuzzer() {
                if (this.multiplayerMode && this.multiplayer.gameState) {
                    const currentPlayerId = this.multiplayer.gameState.currentPlayer;
                    const isMyTurn = currentPlayerId === this.multiplayer.playerId;
                    if (!isMyTurn && this.multiplayer.gameState.roundActive) {
                        // Buzzing another player
                        this.multiplayer.buzzPlayer();
                    } else {
                        // Just play sound if it's your turn or round not active
                        this.playObnoxiousBuzzer();
                    }
                } else {
                    // Single player mode
                    this.playObnoxiousBuzzer();
                }
            }

            showLeaveGameModal() {
                if (!this.multiplayerMode) return;

                const modal = document.getElementById('modal-leave-game');
                const leaveBtn = document.getElementById('btn-leave-individual');
                const endForAllBtn = document.getElementById('end-for-all-btn');
                const leaveWarn = document.getElementById('leave-game-warning');

                const currentPlayers = Object.keys(this.multiplayer.players || {});
                const playerCount = currentPlayers.length;
                const isTeamMode = !!this.multiplayer.gameState?.teams;
                const myId = this.multiplayer.playerId;
                const myTeam = this.multiplayer.players[myId]?.team;

                // Dynamic Fair Play Check:
                // Is this player the last one on their team?
                let isLastOnTeam = false;
                if (isTeamMode && myTeam) {
                    const myTeamMembers = currentPlayers.filter(id => this.multiplayer.players[id].team === myTeam);
                    if (myTeamMembers.length <= 2) {
                        isLastOnTeam = true;
                    }
                }

                // Rule: 2-Player Match OR Last player on a team -> No individual Leave
                const mustEndForAll = (playerCount <= 2) || (isTeamMode && isLastOnTeam);

                if (mustEndForAll) {
                    // Just warn them, but allow leaving. The validateRoomState logic will handle the forced finish.
                    if (leaveBtn) {
                        leaveBtn.classList.remove('hidden');
                        leaveBtn.textContent = 'Leave & End Game';
                        leaveBtn.className = "w-full bg-orange-500 text-white py-3 rounded-xl font-bold";
                        // Use a specific action that triggers END GAME then LEAVE
                        leaveBtn.setAttribute('onclick', "game.confirmLeaveAction('leaveAndEnd')");
                    }
                    if (leaveWarn) {
                        leaveWarn.classList.remove('hidden');
                        leaveWarn.textContent = isLastOnTeam ?
                            "Leaving will leave your team with too few players. The game will end for everyone." :
                            "Leaving a 2-player match will end the game for everyone.";
                    }
                    // Hide separate "End for All" button to avoid confusion, since leaving does the same thing effectively
                    if (endForAllBtn) endForAllBtn.classList.add('hidden');
                } else {
                    if (leaveBtn) {
                        leaveBtn.classList.remove('hidden');
                        leaveBtn.textContent = 'Leave Game';
                        leaveBtn.className = "w-full bg-orange-500 text-white py-3 rounded-xl font-bold";
                        leaveBtn.setAttribute('onclick', "game.confirmLeaveAction('leave')");
                    }
                    if (leaveWarn) leaveWarn.classList.add('hidden');

                    // Show "End for All" only for host as an extra option
                    if (endForAllBtn) {
                        leaveBtn.className = "w-full bg-orange-500 text-white py-3 rounded-xl font-bold";
                    }
                    if (leaveWarn) leaveWarn.classList.add('hidden');

                    // Show "End for All" only for host as an extra option
                    if (endForAllBtn) {
                        if (this.multiplayer.isHost) {
                            endForAllBtn.classList.remove('hidden');
                            endForAllBtn.textContent = 'End for All Players';
                        } else {
                            endForAllBtn.classList.add('hidden');
                        }
                    }
                }

                if (modal) modal.classList.remove('hidden');
            }

            async executeFinishGame() {
                this.hideFinishPrompt();
                await this.multiplayer.endGame();
            }

            hideFinishPrompt() {
                const modal = document.getElementById('modal-finish-game-prompt');
                if (modal) modal.classList.add('hidden');
                // Also clear the flag in DB so it doesn't pop up again for anyone else immediately
                if (this.multiplayer.isHost && this.multiplayer.roomRef) {
                    this.multiplayer.roomRef.child('gameState/promptFinish').set(null);
                }
            }

            hideLeaveGameModal() {
                const modal = document.getElementById('modal-leave-game');
                if (modal) modal.classList.add('hidden');
            }

            confirmLeaveAction(action) {
                // Store the action to execute later
                this.pendingLeaveAction = action;

                // Hide first modal
                this.hideLeaveGameModal();

                // Show confirmation modal with appropriate text
                const confirmModal = document.getElementById('modal-confirm-leave');
                const confirmText = document.getElementById('confirm-leave-text');

                if (action === 'endAll' || action === 'leaveAndEnd') {
                    confirmText.textContent = 'This will end the game for all players. Are you sure?';
                } else {
                    confirmText.textContent = 'You will leave the game. Are you sure?';
                }

                if (confirmModal) confirmModal.classList.remove('hidden');
            }

            cancelLeaveConfirm() {
                const modal = document.getElementById('modal-confirm-leave');
                if (modal) modal.classList.add('hidden');
                this.pendingLeaveAction = null;
            }

            async executeLeaveAction() {
                const modal = document.getElementById('modal-confirm-leave');
                if (modal) modal.classList.add('hidden');

                if (this.pendingLeaveAction === 'endAll') {
                    // End game for all players (Host only feature) - stay in room
                    await this.multiplayer.endGame();
                } else if (this.pendingLeaveAction === 'leaveAndEnd') {
                    // Force end game first
                    await this.multiplayer.endGame();
                    // STAY in room to see results (user request)
                    // The "Main Menu" button on the end screen will handle the actual leaving later.
                } else {
                    // Just leave the room
                    await this.multiplayer.leaveRoom();
                }

                this.pendingLeaveAction = null;
            }

            async handleBuzzResponse(correct) {
                const modal = document.getElementById('modal-end-turn');
                if (modal) modal.classList.add('hidden');

                if (this.multiplayerMode) {
                    // Clear buzz event
                    if (this.multiplayer.roomRef) {
                        await this.multiplayer.roomRef.child('gameState/lastBuzz').set(null);
                    }
                    // If correct, mark as scored, otherwise mark as buzzed
                    if (correct) {
                        await this.multiplayer.nextCard(true);
                    } else {
                        await this.multiplayer.markBuzzed();
                    }
                    // Stay on game screen, just clear modal
                    this.showScreen('game');
                } else {
                    // Single player mode
                    await this.finishRound(correct);
                }
            }
        }

        let game;
        window.onload = () => { game = new TabooPro(); };
    </script>
</body>

</html>