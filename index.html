<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üóÉÔ∏è</text></svg>">
    <title>Taboo Fran√ßais Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap');

        :root {
            --pastel-bg: #f8fafc;
            --primary-pop: #ec4899;
            --secondary-pop: #ef4444;
        }

        body {
            font-family: 'Lexend', sans-serif;
            background-color: var(--pastel-bg);
            touch-action: manipulation;
            overflow-x: hidden;
            min-height: 100dvh;
        }

        .btn-3d {
            transition: all 0.1s ease-in-out;
            box-shadow: 0 4px 0 0 rgba(0, 0, 0, 0.1);
        }

        .btn-3d:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.1);
        }

        .btn-3d:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .buzzer-button {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            border-radius: 50%;
            border: 6px solid #660000;
            box-shadow: 0 10px 0 0 #4d0000, 0 15px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.05s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 1rem;
            user-select: none;
            margin: 0 auto;
        }

        .buzzer-button:active {
            transform: translateY(6px);
            box-shadow: 0 4px 0 0 #4d0000, 0 8px 8px rgba(0, 0, 0, 0.2);
        }

        .level-btn {
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .level-btn.selected {
            border-color: var(--primary-pop);
            transform: scale(1.05);
            background-color: #fdf2f8;
        }

        .overlay {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
        }

        .pulse-timer {
            animation: pulse 1s infinite !important;
            color: #ef4444 !important;
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .buzz-flash {
            animation: flashRed 0.3s ease-out;
        }

        @keyframes flashRed {
            0% {
                background-color: transparent;
            }

            50% {
                background-color: rgba(239, 68, 68, 0.3);
            }

            100% {
                background-color: transparent;
            }
        }

        .word-link {
            text-decoration: none;
            transition: color 0.2s;
        }

        .word-link:hover {
            color: #ec4899;
            text-decoration: underline;
        }

        #word-review-list {
            max-height: 50vh;
            overflow-y: auto;
        }

        .player-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .room-code-display {
            font-family: 'Courier New', monospace;
            letter-spacing: 0.2em;
        }

        .team-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
        }

        .team-a {
            background-color: #fce7f3;
            /* Pink-100 */
            color: #be185d;
            /* Pink-700 */
        }

        .team-b {
            background-color: #dbeafe;
            /* Blue-100 */
            color: #1d4ed8;
            /* Blue-700 */
        }

        .team-score-card {
            padding: 12px;
            border-radius: 16px;
            text-align: center;
            flex: 1;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .team-winner-glow {
            box-shadow: 0 0 20px rgba(236, 72, 153, 0.3);
            border: 2px solid #ec4899;
        }

        .team-winner-glow-b {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
            border: 2px solid #3b82f6;
        }

        /* Team Themes for Game Board */
        .team-a-theme {
            border-color: #f472b6 !important;
            /* Pink-400 */
        }

        .team-b-theme {
            border-color: #60a5fa !important;
            /* Blue-400 */
        }

        .your-team-pill {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 60;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 10px;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .role-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 4px;
            animation: pulse-role 2s infinite;
        }

        @keyframes pulse-role {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .winner-animation {
            animation: celebrate 1s ease-in-out infinite;
        }

        @keyframes celebrate {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
            }

            25% {
                transform: scale(1.1) rotate(-5deg);
            }

            75% {
                transform: scale(1.1) rotate(5deg);
            }
        }

        .loser-animation {
            animation: console 2s ease-in-out;
            opacity: 0.7;
        }

        @keyframes console {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }

            100% {
                transform: translateY(0);
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #ec4899;
            position: absolute;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>

<body id="main-body" class="flex flex-col items-center justify-start p-4 pt-20 transition-colors min-h-screen">

    <!-- Persistent Team Badge -->
    <div id="your-team-badge" class="hidden your-team-pill"></div>

    <!-- HUD -->
    <div id="game-hud"
        class="fixed top-0 left-0 w-full p-2 flex justify-center items-center z-50 opacity-0 transition-opacity pointer-events-none">
        <div
            class="bg-white/80 backdrop-blur-md px-4 py-2 rounded-2xl shadow-lg border border-slate-200 pointer-events-auto flex items-center gap-4 max-w-full overflow-x-auto no-scrollbar">

            <!-- Leave Button -->
            <button id="leave-game-btn" onclick="game.showLeaveGameModal()"
                class="hidden bg-slate-100 hover:bg-slate-200 text-slate-600 px-3 py-1.5 rounded-xl text-[10px] font-black uppercase transition-colors">
                Leave
            </button>

            <div class="h-4 w-[1px] bg-slate-200 hidden" id="leave-separator"></div>

            <!-- Score -->
            <div class="flex flex-col items-center min-w-[40px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Score</span>
                <div id="score-display" class="text-lg font-black text-pink-500 leading-none">0</div>
            </div>

            <!-- Timer -->
            <div id="timer-box"
                class="flex flex-col items-center bg-slate-50 px-3 py-1 rounded-xl border border-slate-100 min-w-[50px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Time</span>
                <div id="timer-display" class="text-xl font-black text-slate-700 leading-none">60</div>
            </div>

            <!-- Stack -->
            <div id="stack-box" class="flex flex-col items-center min-w-[40px]">
                <span class="text-[8px] uppercase font-black text-slate-400 leading-none mb-1">Stack</span>
                <div id="stack-display" class="text-lg font-black text-slate-700 leading-none">0</div>
            </div>

            <div class="h-4 w-[1px] bg-slate-200"></div>

            <!-- Connection Status -->
            <div id="connection-status" class="flex items-center gap-1.5">
                <span id="connection-dot" class="w-2.5 h-2.5 rounded-full bg-slate-300 shadow-inner"></span>
                <span id="connection-text" class="text-[10px] font-black text-slate-500 uppercase">Offline</span>
            </div>
        </div>
    </div>

    <main class="w-full max-w-md my-auto">
        <!-- START SCREEN -->
        <div id="screen-start" class="text-center">
            <div class="text-6xl mb-4">üá´üá∑</div>
            <h1 class="text-3xl font-black text-slate-800 mb-2">Taboo Fran√ßais</h1>
            <p id="total-card-count" class="text-[10px] font-black text-pink-500 uppercase mb-4 tracking-widest">
                Loading...</p>

            <div class="grid grid-cols-2 gap-3 mb-6">
                <button onclick="game.setLevel('A1', this)"
                    class="level-btn bg-white p-4 rounded-2xl shadow-sm text-left">
                    <div class="font-black text-pink-500 text-xl">A1</div>
                    <div class="text-[10px] text-slate-400 uppercase font-bold">Beginner</div>
                </button>
                <button onclick="game.setLevel('A2', this)"
                    class="level-btn bg-white p-4 rounded-2xl shadow-sm text-left">
                    <div class="font-black text-blue-500 text-xl">A2</div>
                    <div class="text-[10px] text-slate-400 uppercase font-bold">Elementary</div>
                </button>
                <button onclick="game.setLevel('B1', this)"
                    class="level-btn bg-white p-4 rounded-2xl shadow-sm text-left">
                    <div class="font-black text-purple-500 text-xl">B1</div>
                    <div class="text-[10px] text-slate-400 uppercase font-bold">Intermediate</div>
                </button>
                <button onclick="game.setLevel('B2', this)"
                    class="level-btn bg-white p-4 rounded-2xl shadow-sm text-left">
                    <div class="font-black text-orange-500 text-xl">B2</div>
                    <div class="text-[10px] text-slate-400 uppercase font-bold">Upper Inter.</div>
                </button>
            </div>

            <div class="flex gap-3 mb-4">
                <button id="btn-start-round" disabled onclick="game.startRound()"
                    class="btn-3d flex-1 bg-slate-200 text-slate-400 py-3 rounded-2xl font-black flex flex-col items-center justify-center leading-tight">
                    <span id="start-btn-main" class="text-xl">Select a Level</span>
                    <span id="start-btn-sub"
                        class="text-[10px] uppercase tracking-widest opacity-80 mt-1 hidden"></span>
                </button>
                <button id="btn-multiplayer" onclick="game.showMultiplayerOptions()"
                    class="btn-3d flex-1 bg-blue-500 text-white py-4 rounded-2xl text-xl font-black">
                    Multiplayer
                </button>
            </div>
            <button id="btn-reset-cards" onclick="game.resetAllCards()"
                class="w-full py-2 text-slate-400 font-bold text-sm underline mb-8">
                Put all cards back in play
            </button>

            <div class="flex flex-col items-center">
                <div onmousedown="game.handleBuzzer()" class="buzzer-button">BUZZ!</div>
            </div>
        </div>

        <div id="screen-game" class="hidden flex flex-col items-center">
            <div id="card-container"
                class="w-full bg-white rounded-[2rem] shadow-xl border-4 border-pink-100 p-8 mb-8 text-center min-h-[380px] flex flex-col justify-between">
                <div>
                    <div id="card-level-tag"
                        class="inline-block px-3 py-1 rounded-full bg-pink-50 text-pink-500 text-[10px] font-black mb-4 uppercase">
                        Level A1</div>
                    <h2 id="word-to-guess" class="text-4xl font-black text-slate-800 mb-6 uppercase leading-tight">...
                    </h2>
                    <ul id="taboo-words" class="space-y-2"></ul>
                </div>
            </div>

            <!-- Main Actions (Skip, Buzzed, Correct) -->
            <div class="flex gap-4 w-full mb-8">
                <button id="btn-skip" onclick="game.skipCard()"
                    class="btn-3d flex-1 bg-slate-200 text-slate-500 py-4 rounded-2xl font-bold">
                    Skip (1/1)
                </button>
                <button id="btn-buzzed" onclick="game.markBuzzed()"
                    class="btn-3d flex-1 bg-red-500 text-white py-4 rounded-2xl font-bold hidden">
                    Buzzed
                </button>
                <button onclick="game.nextCard(true)"
                    class="btn-3d flex-[2] bg-pink-500 text-white py-4 rounded-2xl font-black text-lg">
                    Correct! ‚úÖ
                </button>
            </div>

            <!-- Start round button for active player -->
            <div id="multiplayer-start-round" class="hidden w-full mb-8">
                <button onclick="game.startMultiplayerRound()"
                    class="btn-3d w-full bg-green-500 text-white py-4 rounded-2xl font-black text-lg">
                    Start Your Round
                </button>
            </div>

            <!-- Multiplayer buzzer for opposing players -->
            <div id="multiplayer-buzzer-container" class="hidden w-full mb-8">
                <div onmousedown="game.handleBuzzer()" class="buzzer-button">BUZZ!</div>
                <p class="text-[10px] text-slate-400 font-bold uppercase mt-2 text-center">Buzz if you hear a taboo
                    word!</p>
            </div>

            <!-- Multiplayer turn indicator -->
            <div id="multiplayer-turn-indicator"
                class="hidden w-full mb-4 rounded-2xl p-4 border-2 transition-all duration-300">
                <div id="turn-role-badge" class="role-badge hidden"></div>
                <div class="text-lg font-black uppercase tracking-tight leading-none mb-1" id="turn-indicator-text">Your
                    turn!</div>
                <div class="text-xs font-bold opacity-80" id="turn-indicator-subtext"></div>
            </div>

            <!-- Waiting for player message -->
            <div id="multiplayer-waiting"
                class="hidden w-full mb-4 bg-slate-50 border-2 border-slate-200 rounded-2xl p-4">
                <div class="text-sm font-bold text-slate-600" id="waiting-text">Waiting for player to start...</div>
            </div>

            <!-- Player list (multiplayer) -->
            <div id="multiplayer-player-list"
                class="hidden w-full mb-4 bg-white rounded-2xl p-4 border-2 border-slate-100">
                <div class="text-xs text-slate-400 font-bold uppercase mb-2">Players</div>
                <div id="game-players-list" class="space-y-1"></div>
            </div>
        </div>

        <!-- SUMMARY SCREEN -->
        <div id="screen-summary" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üéâ</div>
            <h2 id="summary-title" class="text-3xl font-black text-slate-800 mb-2">Round Finished</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-4 w-full shadow-sm">
                <div id="round-score-val" class="text-6xl font-black text-pink-500 mb-2">0</div>
                <div class="text-xs text-slate-400 uppercase font-black tracking-widest mb-6">Points this round</div>

                <div class="flex flex-col items-center py-4">
                    <div onmousedown="game.playObnoxiousBuzzer()" class="buzzer-button">BUZZ!</div>
                    <p class="text-[10px] text-slate-400 font-bold uppercase mt-2">Buzz the Others!</p>
                </div>
            </div>

            <div class="flex flex-col gap-3 w-full">
                <button onclick="game.startRound()"
                    class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                    Next Round
                </button>
                <button onclick="game.showEndGame()" class="w-full py-2 text-slate-400 font-bold text-sm underline">
                    Final Score & Breakdown
                </button>
            </div>
        </div>

        <!-- MULTIPLAYER OPTIONS SCREEN -->
        <div id="screen-multiplayer-options" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üë•</div>
            <h2 class="text-3xl font-black text-slate-800 mb-6">Multiplayer Mode</h2>
            <div class="flex flex-col gap-4 w-full">
                <input id="input-host-name" type="text" maxlength="20" placeholder="Your Name (Optional)"
                    class="w-full px-4 py-3 rounded-xl border-2 border-slate-200 text-center text-lg font-bold">
                <button onclick="game.createRoom()"
                    class="btn-3d w-full bg-pink-500 text-white py-4 rounded-2xl text-xl font-black">
                    Create Room
                </button>
                <button onclick="game.showJoinRoom()"
                    class="btn-3d w-full bg-blue-500 text-white py-4 rounded-2xl text-xl font-black">
                    Join Room
                </button>
                <button onclick="game.showScreen('start')"
                    class="w-full py-2 text-slate-400 font-bold text-sm underline">
                    Back to Main Menu
                </button>
            </div>
        </div>

        <!-- JOIN ROOM SCREEN -->
        <div id="screen-join-room" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üîó</div>
            <h2 class="text-3xl font-black text-slate-800 mb-4">Join Room</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <label class="block text-left text-sm font-bold text-slate-600 mb-2">Room Code</label>
                <input id="input-room-code" type="text" maxlength="4" placeholder="AB12"
                    class="w-full px-4 py-3 rounded-xl border-2 border-slate-200 text-center text-2xl font-black room-code-display uppercase mb-4"
                    style="letter-spacing: 0.2em;">
                <label class="block text-left text-sm font-bold text-slate-600 mb-2">Your Name</label>
                <input id="input-player-name" type="text" maxlength="20" placeholder="Enter your name"
                    class="w-full px-4 py-3 rounded-xl border-2 border-slate-200 text-center text-lg font-bold mb-4">
                <button onclick="game.joinRoom()"
                    class="btn-3d w-full bg-blue-500 text-white py-3 rounded-xl font-black">
                    Join
                </button>
            </div>
            <button onclick="game.showMultiplayerOptions()"
                class="w-full py-2 text-slate-400 font-bold text-sm underline">
                Back
            </button>
        </div>

        <!-- LOBBY SCREEN -->
        <div id="screen-lobby" class="hidden text-center flex flex-col items-center">
            <div class="text-6xl mb-4">üè†</div>
            <h2 class="text-3xl font-black text-slate-800 mb-4">Room Lobby</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <div class="mb-6">
                    <div class="text-xs text-slate-400 font-bold uppercase mb-2">Room Code</div>
                    <div id="lobby-room-code" class="text-4xl font-black room-code-display text-pink-500 mb-2">----
                    </div>
                    <button id="btn-copy-code" onclick="game.copyRoomCode()"
                        class="text-xs text-blue-500 font-bold underline">
                        Copy Code
                    </button>
                </div>
                <div class="mb-6">
                    <div class="text-xs text-slate-400 font-bold uppercase mb-3 text-left">Players</div>
                    <div id="lobby-players-list" class="space-y-2 text-left"></div>
                </div>
                <div id="lobby-host-controls" class="hidden">
                    <label class="block text-left text-sm font-bold text-slate-600 mb-2">Select Level</label>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <button onclick="game.setMultiplayerLevel('A1', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-pink-500 text-lg">A1</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Beginner</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('A2', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-blue-500 text-lg">A2</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Elementary</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('B1', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-purple-500 text-lg">B1</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Intermediate</div>
                        </button>
                        <button onclick="game.setMultiplayerLevel('B2', this)"
                            class="level-btn bg-white p-3 rounded-xl shadow-sm text-left border-2 border-slate-200">
                            <div class="font-black text-orange-500 text-lg">B2</div>
                            <div class="text-[10px] text-slate-400 uppercase font-bold">Upper Inter.</div>
                        </button>
                    </div>
                    <button id="btn-start-game" disabled onclick="game.startMultiplayerGame()"
                        class="btn-3d w-full bg-slate-200 text-slate-400 py-4 rounded-2xl text-xl font-black">
                        Select Level to Start
                    </button>
                </div>
                <div id="lobby-waiting" class="text-slate-500 text-sm">
                    Waiting for host to start the game...
                </div>
            </div>
            <button onclick="game.leaveRoom()" class="w-full py-2 text-slate-400 font-bold text-sm underline">
                Leave Room
            </button>
        </div>

        <!-- END GAME SCREEN -->
        <div id="screen-endgame" class="hidden text-center flex flex-col items-center w-full">
            <h2 class="text-3xl font-black text-slate-800 mb-2">Session Recap</h2>
            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <div class="flex justify-around mb-6 pb-6 border-b border-slate-100">
                    <div class="text-center">
                        <div id="total-final-score" class="text-4xl font-black text-pink-500">0</div>
                        <div class="text-[10px] text-slate-400 font-black uppercase">Total Points</div>
                    </div>
                    <div class="text-center">
                        <div id="total-rounds-count" class="text-4xl font-black text-slate-800">0</div>
                        <div class="text-[10px] text-slate-400 font-black uppercase">Rounds</div>
                    </div>
                </div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Round Breakdown</h3>
                <div id="round-history-list" class="space-y-2 mb-6"></div>

                <button id="btn-show-review" onclick="game.showWordReview()"
                    class="w-full bg-pink-100 text-pink-600 py-3 rounded-2xl font-black text-sm">
                    Review Guessed Words?
                </button>

                <div id="review-section" class="hidden mt-6 text-left">
                    <h3 class="text-[10px] font-black text-slate-400 uppercase mb-3">Word Review (Click for Definition)
                    </h3>
                    <div id="word-review-list" class="space-y-2"></div>
                </div>
            </div>
            <button onclick="location.reload()"
                class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                Main Menu
            </button>
        </div>

        <!-- MULTIPLAYER END GAME SCREEN -->
        <div id="screen-multiplayer-endgame" class="hidden text-center flex flex-col items-center w-full">
            <div id="winner-indicator" class="mb-4">
                <div id="winner-emoji" class="text-6xl mb-2"></div>
                <h2 id="winner-title" class="text-3xl font-black text-slate-800 mb-2"></h2>
                <p id="winner-subtitle" class="text-sm text-slate-500 mb-4"></p>
            </div>

            <div class="bg-white rounded-3xl p-6 border-2 border-slate-100 mb-6 w-full shadow-sm">
                <!-- Team Scores Summary -->
                <div id="team-scores-container" class="hidden mb-8">
                    <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Team Results</h3>
                    <div class="flex gap-3">
                        <div id="team-a-score-card" class="team-score-card team-a">
                            <div class="text-[10px] font-black opacity-60">TEAM A</div>
                            <div id="team-a-total-pts" class="text-3xl font-black">0</div>
                            <div class="text-[9px] font-bold">TOTAL POINTS</div>
                        </div>
                        <div id="team-b-score-card" class="team-score-card team-b">
                            <div class="text-[10px] font-black opacity-60">TEAM B</div>
                            <div id="team-b-total-pts" class="text-3xl font-black">0</div>
                            <div class="text-[9px] font-bold">TOTAL POINTS</div>
                        </div>
                    </div>
                </div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Player Standings</h3>
                <div id="final-scores-list" class="space-y-2 mb-6"></div>

                <h3 class="text-[10px] font-black text-slate-400 uppercase text-left mb-3">Your Words</h3>
                <p class="text-xs text-slate-500 mb-3 text-left">All the words you had to describe:</p>
                <div id="my-words-list" class="space-y-2 mb-6"></div>
            </div>

            <button onclick="location.reload()"
                class="btn-3d w-full bg-slate-800 text-white py-4 rounded-2xl text-xl font-black">
                Main Menu
            </button>
        </div>
    </main>

    <!-- MODALS -->
    <div id="modal-end-turn" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">üîî</div>
            <h3 class="text-xl font-black mb-2">Buzzer!</h3>
            <p class="text-slate-500 mb-6 text-sm" id="buzz-modal-text">Did you get <span id="last-word-hint"
                    class="font-bold text-pink-500"></span> correctly?</p>
            <div class="flex gap-3">
                <button onclick="game.handleBuzzResponse(false)"
                    class="flex-1 bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">No</button>
                <button onclick="game.handleBuzzResponse(true)"
                    class="flex-1 bg-pink-500 text-white py-3 rounded-xl font-bold">Yes!</button>
            </div>
        </div>
    </div>

    <!-- FINISH GAME PROMPT MODAL -->
    <div id="modal-finish-game-prompt"
        class="hidden fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-[200] flex items-center justify-center p-4">
        <div class="bg-white rounded-3xl p-8 max-w-sm w-full text-center shadow-2xl">
            <div class="text-4xl mb-4">‚öñÔ∏è</div>
            <h3 class="text-2xl font-black text-slate-800 mb-2">Teams Unbalanced</h3>
            <p id="finish-game-msg" class="text-slate-500 mb-8 leading-relaxed">Too many players have left. The game
                must end to keep it fair for everyone.</p>
            <div class="space-y-3">
                <button id="finish-and-see-results-btn" onclick="game.multiplayer.endGame()"
                    class="w-full bg-slate-800 text-white py-4 rounded-2xl font-black text-lg shadow-lg hover:bg-slate-700 transition-colors">
                    See Game Results
                </button>
                <button id="continue-anyway-btn" onclick="game.multiplayer.continueAnyway()"
                    class="hidden w-full bg-slate-100 text-slate-600 py-3 rounded-2xl font-black text-sm">
                    Continue anyway
                </button>
            </div>
        </div>
    </div>

    <!-- Leave Game Modal - Step 1: Choose action -->
    <div id="modal-leave-game" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">üëã</div>
            <h3 class="text-xl font-black mb-2">Leave Game?</h3>
            <p class="text-slate-500 mb-6 text-sm">What would you like to do?</p>
            <div class="flex flex-col gap-3">
                <button onclick="game.confirmLeaveAction('leave')"
                    class="w-full bg-orange-500 text-white py-3 rounded-xl font-bold">
                    Leave Game
                </button>
                <button id="end-for-all-btn" onclick="game.confirmLeaveAction('endAll')"
                    class="w-full bg-red-500 text-white py-3 rounded-xl font-bold">
                    End for All Players
                </button>
                <button onclick="game.hideLeaveGameModal()"
                    class="w-full bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Leave Game Modal - Step 2: Confirm action -->
    <div id="modal-confirm-leave" class="hidden fixed inset-0 z-[100] flex items-center justify-center p-6 overlay">
        <div class="bg-white rounded-3xl p-8 shadow-2xl max-w-xs w-full text-center">
            <div class="text-4xl mb-4">‚ö†Ô∏è</div>
            <h3 class="text-xl font-black mb-2">Are you sure?</h3>
            <p id="confirm-leave-text" class="text-slate-500 mb-6 text-sm">This action cannot be undone.</p>
            <div class="flex gap-3">
                <button onclick="game.cancelLeaveConfirm()"
                    class="flex-1 bg-slate-100 text-slate-600 py-3 rounded-xl font-bold">Cancel</button>
                <button id="confirm-leave-btn" onclick="game.executeLeaveAction()"
                    class="flex-1 bg-red-500 text-white py-3 rounded-xl font-bold">Yes, I'm sure</button>
            </div>
        </div>
    </div>

    <script>
        const REMOTE_URL = 'https://raw.githubusercontent.com/meemiemeemie/french-taboo/main/word-list.csv';

        // Firebase configuration - Replace with your Firebase project config
        const firebaseConfig = {
            apiKey: "AIzaSyDwuX6WaTRSLAeDqdex0VyapFKYEJ5OGfQ",
            authDomain: "french-taboo.firebaseapp.com",
            databaseURL: "https://french-taboo-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "french-taboo",
            storageBucket: "french-taboo.firebasestorage.app",
            messagingSenderId: "876947251507",
            appId: "1:876947251507:web:3a1712871ea0fa411e1e46",
            measurementId: "G-LPCQEL2RXM"
        };

        class MultiplayerManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.db = null;
                this.roomRef = null;
                this.playerId = null;
                this.roomCode = null;
                this.isHost = false;
                this.players = {};
                this.gameState = null;
                this.sessionPlayedIds = new Set();
                this.listeners = [];
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
            }

            initialize() {
                try {
                    // Check if Firebase is loaded
                    if (typeof firebase === 'undefined') {
                        console.error('Firebase SDK not loaded');
                        return false;
                    }

                    if (!firebase.apps || firebase.apps.length === 0) {
                        // Check if config is valid
                        if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes('YOUR_API_KEY')) {
                            console.warn('Firebase configuration is incomplete.');
                            return false;
                        }
                        firebase.initializeApp(firebaseConfig);
                    }
                    this.db = firebase.database();
                    this.playerId = this.generatePlayerId();

                    // Add presence logic
                    const connectedRef = this.db.ref('.info/connected');
                    connectedRef.on('value', (snap) => {
                        if (snap.val() === true && this.roomRef) {
                            const pRef = this.roomRef.child(`players/${this.playerId}`);
                            pRef.onDisconnect().remove();
                        }
                    });

                } catch (e) {
                    console.error('Firebase initialization error:', e);
                    return false;
                }
                return true;
            }

            generatePlayerId() {
                return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let code = '';
                for (let i = 0; i < 4; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }

            async createRoom(hostName) {
                try {
                    if (!this.db) {
                        if (!this.initialize()) return null;
                    }

                    let attempts = 0;
                    let code;
                    let roomExists = true;

                    // Try to generate unique code (max 10 attempts)
                    while (roomExists && attempts < 10) {
                        code = this.generateRoomCode();
                        const roomPath = `rooms/${code}`;
                        const snapshot = await this.db.ref(roomPath).once('value');
                        roomExists = snapshot.exists();
                        attempts++;
                    }

                    if (roomExists) {
                        alert('Failed to create room. Please try again.');
                        return null;
                    }

                    this.roomCode = code;
                    this.isHost = true;

                    const roomPath = `rooms/${code}`;
                    this.roomRef = this.db.ref(roomPath);

                    // Create room with expiration (1 hour)
                    const expirationTime = Date.now() + (60 * 60 * 1000);
                    await this.roomRef.set({
                        host: this.playerId,
                        createdAt: firebase.database.ServerValue.TIMESTAMP,
                        expiresAt: expirationTime,
                        gameState: {
                            status: 'lobby',
                            level: null,
                            currentPlayer: null,
                            currentCard: null,
                            timer: 60,
                            roundActive: false,
                            playedIds: {}
                        },
                        players: {}
                    });

                    // Add host as first player
                    await this.joinRoomAsPlayer(hostName || 'Host');
                    this.setupRoomListeners();

                    // Set up individual player cleanup on disconnect
                    this.roomRef.child(`players/${this.playerId}`).onDisconnect().remove();

                    return code;
                } catch (error) {
                    console.error('Error creating room:', error);
                    alert('Failed to create room. Please check your connection and try again.');
                    return null;
                }
            }

            async joinRoom(code, playerName) {
                try {
                    if (!this.db) {
                        if (!this.initialize()) return false;
                    }

                    this.roomCode = code;
                    const roomPath = `rooms/${code}`;
                    this.roomRef = this.db.ref(roomPath);

                    // Check if room exists
                    const snapshot = await this.roomRef.once('value');
                    if (!snapshot.exists()) {
                        alert('Room not found. Please check the room code.');
                        return false;
                    }

                    const roomData = snapshot.val();
                    if (roomData.gameState && roomData.gameState.status === 'playing') {
                        // Allow joining during game but show message
                        const joinDuringGame = confirm('Game is already in progress. You can join as a spectator. Continue?');
                        if (!joinDuringGame) return false;
                    }

                    // Check player limit (8 players max)
                    const currentPlayers = Object.keys(roomData.players || {}).length;
                    if (currentPlayers >= 8) {
                        alert('Room is full (8 players maximum).');
                        return false;
                    }

                    this.isHost = roomData.host === this.playerId;
                    await this.joinRoomAsPlayer(playerName);
                    this.setupRoomListeners();
                    return true;
                } catch (error) {
                    console.error('Error joining room:', error);
                    alert('Failed to join room. Please check your connection and try again.');
                    return false;
                }
            }

            async joinRoomAsPlayer(playerName) {
                if (!this.roomRef) return;

                // Sanitize player name
                const sanitizedName = playerName.substring(0, 20).replace(/[<>]/g, '') || 'Player';

                const playerData = {
                    name: sanitizedName,
                    joinedAt: firebase.database.ServerValue.TIMESTAMP,
                    score: 0,
                    team: null,
                    online: true
                };

                await this.roomRef.child(`players/${this.playerId}`).set(playerData);
                // Keep online status synced
                this.roomRef.child(`players/${this.playerId}/online`).onDisconnect().set(false);
            }

            setupRoomListeners() {
                if (!this.roomRef) return;

                // Listen to players
                this.roomRef.child('players').on('value', async (snapshot) => {
                    this.players = snapshot.val() || {};
                    this.updatePlayersList();

                    // Host Migration Logic
                    if (this.roomRef && this.players) {
                        const roomSnapshot = await this.roomRef.once('value');
                        const roomData = roomSnapshot.val();
                        const currentHostId = roomData?.host;

                        // If host is missing or offline
                        if (!currentHostId || !this.players[currentHostId] || this.players[currentHostId].online === false) {
                            // Find next available player (sorted by joinedAt)
                            const playerArray = Object.entries(this.players)
                                .map(([id, data]) => ({ id, ...data }))
                                .filter(p => p.online !== false)
                                .sort((a, b) => (a.joinedAt || 0) - (b.joinedAt || 0));

                            if (playerArray.length > 0) {
                                const nextHostId = playerArray[0].id;
                                // If I am the next in line, nominate myself as host
                                if (nextHostId === this.playerId && currentHostId !== this.playerId) {
                                    console.log("Promoting self to Host...");
                                    await this.roomRef.child('host').set(this.playerId);
                                }
                            }
                        }
                    }
                });

                // Listen to Host changes
                this.roomRef.child('host').on('value', (snapshot) => {
                    const newHostId = snapshot.val();
                    const wasHost = this.isHost;
                    this.isHost = (newHostId === this.playerId);

                    if (this.isHost && !wasHost) {
                        console.log("I am the new Host! Starting timer authority...");
                        this.startHostTimer();
                        this.validateRoomState(); // Immediate check after promotion
                        this.updatePlayersList();
                    }
                });

                this.roomRef.child('players').on('child_removed', (snapshot) => {
                    if (this.isHost && this.gameState && this.gameState.status === 'playing') {
                        this.validateRoomState();
                    }
                });

                // Listen to game state
                this.roomRef.child('gameState').on('value', (snapshot) => {
                    this.gameState = snapshot.val();
                    if (this.gameState) {
                        // Sync played card IDs
                        if (this.gameState.playedIds) {
                            this.sessionPlayedIds = new Set(Object.keys(this.gameState.playedIds));
                        } else {
                            this.sessionPlayedIds = new Set();
                        }
                        this.handleGameStateChange();
                    }
                });

                // Listen to buzz events separately for better handling
                this.roomRef.child('gameState/lastBuzz').on('value', (snapshot) => {
                    const buzzData = snapshot.val();
                    if (buzzData && this.gameState && this.gameState.roundActive) {
                        const currentPlayerId = this.gameState.currentPlayer;
                        if (buzzData.playerId !== currentPlayerId && currentPlayerId === this.playerId) {
                            // Someone buzzed me - show modal
                            this.showBuzzModal(buzzData);
                        }
                    }
                });

                // Handle connection state
                const connectedRef = this.db.ref('.info/connected');
                connectedRef.on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        // Connected
                        this.reconnectAttempts = 0;
                        this.hideConnectionError();
                    } else {
                        // Disconnected
                        this.showConnectionError();
                        this.attemptReconnect();
                    }
                });

                // Handle disconnections
                if (this.playerId) {
                    this.roomRef.child(`players/${this.playerId}`).onDisconnect().remove();
                }

                // Start host timer if applicable
                this.startHostTimer();
            }

            startHostTimer() {
                if (!this.isHost || this.hostTimer) return;

                this.hostTimer = setInterval(async () => {
                    if (this.gameState && this.gameState.roundActive && this.gameState.timer > 0) {
                        const newTimer = this.gameState.timer - 1;
                        await this.roomRef.child('gameState/timer').set(newTimer);

                        if (newTimer === 0) {
                            // Timer expired - end the round
                            // The active player will handle this via the handleGameStateChange
                        }
                    }
                }, 1000);
            }

            sanitizeKey(key) {
                if (!key) return "unknown";
                // Firebase keys cannot contain . $ # [ ] /
                return key.toString().replace(/[\.\$#\[\]\/]/g, '_');
            }

            async addSessionPlayed(id) {
                if (!this.roomRef || !id) return;
                try {
                    const safeId = this.sanitizeKey(id);
                    await this.roomRef.child(`gameState/playedIds/${safeId}`).set(true);
                } catch (e) {
                    console.error("Error adding played ID:", e);
                }
            }

            showConnectionError() {
                const dot = document.getElementById('connection-dot');
                const text = document.getElementById('connection-text');
                if (dot) dot.className = 'w-2.5 h-2.5 rounded-full bg-red-500 animate-pulse';
                if (text) text.textContent = 'Disconnected';
                console.warn('Connection lost. Attempting to reconnect...');
            }

            hideConnectionError() {
                const dot = document.getElementById('connection-dot');
                const text = document.getElementById('connection-text');
                if (dot) dot.className = 'w-2.5 h-2.5 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.5)]';
                if (text) text.textContent = 'Online';
            }

            async attemptReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    alert('Connection lost. Please refresh the page.');
                    return;
                }

                this.reconnectAttempts++;
                setTimeout(async () => {
                    if (this.roomCode && !this.db.ref('.info/connected').val()) {
                        try {
                            // Try to rejoin room
                            const roomPath = `rooms/${this.roomCode}`;
                            const snapshot = await this.db.ref(roomPath).once('value');
                            if (snapshot.exists()) {
                                this.roomRef = this.db.ref(roomPath);
                                this.setupRoomListeners();
                            }
                        } catch (e) {
                            console.error('Reconnection failed:', e);
                            this.attemptReconnect();
                        }
                    }
                }, 2000 * this.reconnectAttempts);
            }

            updatePlayersList() {
                const listEl = document.getElementById('lobby-players-list');
                const gameListEl = document.getElementById('game-players-list');
                if (!listEl && !gameListEl) return;

                const playerArray = Object.entries(this.players).map(([id, data]) => ({
                    id,
                    ...data
                }));

                const colors = ['#ec4899', '#3b82f6', '#8b5cf6', '#f59e0b', '#10b981', '#ef4444', '#06b6d4', '#f97316'];
                let colorIndex = 0;

                const renderPlayer = (player, isGame = false) => {
                    const color = colors[colorIndex % colors.length];
                    colorIndex++;
                    const isCurrentPlayer = player.id === this.playerId;
                    const isHostPlayer = this.isHost && player.id === this.playerId;
                    const hostBadge = isHostPlayer ? '<span class="text-[8px] bg-pink-100 text-pink-600 px-2 py-0.5 rounded-full ml-2">HOST</span>' : '';
                    const teamBadge = player.team ? `<span class="team-indicator ${player.team === 'A' ? 'team-a' : 'team-b'}">Team ${player.team}</span>` : '';
                    const onlineStatus = player.online === false ? '<span class="text-[8px] text-slate-300 ml-2 italic">(offline)</span>' : '';

                    const div = document.createElement('div');
                    div.className = `flex justify-between items-center p-2 rounded-lg ${isCurrentPlayer ? 'bg-pink-50 border-2 border-pink-200' : 'bg-slate-50'} ${player.online === false ? 'opacity-50' : ''}`;
                    div.innerHTML = `
                        <div class="flex items-center">
                            <span class="player-color-dot" style="background-color: ${player.online === false ? '#cbd5e1' : color}"></span>
                            <span class="font-bold text-slate-700">${player.name}</span>
                            ${hostBadge}
                            ${teamBadge}
                            ${onlineStatus}
                        </div>
                        ${isGame ? `<span class="font-black text-slate-800">${player.score || 0}</span>` : ''}
                    `;
                    return div;
                };

                if (listEl) {
                    listEl.innerHTML = '';
                    playerArray.forEach(player => {
                        listEl.appendChild(renderPlayer(player, false));
                    });
                }

                if (gameListEl) {
                    gameListEl.innerHTML = '';
                    playerArray.forEach(player => {
                        gameListEl.appendChild(renderPlayer(player, true));
                    });
                }

                // Show/hide host controls
                const hostControls = document.getElementById('lobby-host-controls');
                const waitingMsg = document.getElementById('lobby-waiting');
                if (hostControls && waitingMsg) {
                    if (this.isHost) {
                        hostControls.classList.remove('hidden');
                        waitingMsg.classList.add('hidden');
                    } else {
                        hostControls.classList.add('hidden');
                        waitingMsg.classList.remove('hidden');
                    }
                }
            }

            async startGame(level) {
                if (!this.isHost || !this.roomRef) return;

                const playerArray = Object.keys(this.players);
                if (playerArray.length < 2) {
                    alert('Need at least 2 players to start!');
                    return;
                }

                // Determine game mode based on player count
                let teams = null;
                let turnOrder = [];

                if (playerArray.length === 2 || playerArray.length === 3) {
                    // Free-for-all Mode for 2-3 players
                    turnOrder = [...playerArray].sort(() => Math.random() - 0.5);
                } else {
                    // Team Mode for 4+ players (including 5, 7 with uneven teams)
                    const teamData = this.formTeams(playerArray);
                    teams = teamData.teams;
                    turnOrder = teamData.turnOrder;
                }

                // Determine first player
                const firstPlayer = turnOrder[0];

                await this.roomRef.child('gameState').set({
                    status: 'playing',
                    level: level,
                    currentPlayer: firstPlayer,
                    currentCard: null,
                    timer: 60,
                    roundActive: false,
                    teams: teams,
                    turnOrder: turnOrder,
                    currentTurnIndex: 0,
                    initialPlayerCount: playerArray.length
                });
            }

            formTeams(playerIds) {
                // Shuffle players first
                const shuffled = [...playerIds].sort(() => Math.random() - 0.5);
                const teams = { A: [], B: [] };

                // Distribute players and build interleaved turn order
                // A1, B1, A2, B2, ...
                const turnOrder = [];

                // Split into two teams (can be uneven for 5, 7 players)
                // For odd numbers, randomly decide which team gets the extra player
                const totalPlayers = shuffled.length;
                const teamASize = Math.floor(totalPlayers / 2);
                const teamBSize = totalPlayers - teamASize;

                // Randomly decide which team gets the extra player for odd counts
                const teamAGetsExtra = Math.random() < 0.5;
                const teamA = teamAGetsExtra && totalPlayers % 2 === 1
                    ? shuffled.slice(0, teamASize + 1)
                    : shuffled.slice(0, teamASize);
                const teamB = teamAGetsExtra && totalPlayers % 2 === 1
                    ? shuffled.slice(teamASize + 1)
                    : shuffled.slice(teamASize);

                // Assign to team objects and update DB
                teamA.forEach(id => {
                    teams.A.push(id);
                    this.roomRef.child(`players/${id}/team`).set('A');
                });

                teamB.forEach(id => {
                    teams.B.push(id);
                    this.roomRef.child(`players/${id}/team`).set('B');
                });

                // Create interleaved order (A1, B1, A2, B2, ...)
                const maxTeamSize = Math.max(teamA.length, teamB.length);
                for (let i = 0; i < maxTeamSize; i++) {
                    if (teamA[i]) turnOrder.push(teamA[i]);
                    if (teamB[i]) turnOrder.push(teamB[i]);
                }

                return { teams, turnOrder };
            }

            async startRound() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return; // Not this player's turn

                // Get a random card
                const pool = this.game.getPool(this.gameState.level);
                if (pool.length === 0) {
                    await this.endGame();
                    return;
                }

                const card = pool[Math.floor(Math.random() * pool.length)];
                this.game.currentCard = card;
                await this.addSessionPlayed(card.id); // Mark as played immediately in session

                await this.roomRef.child('gameState').update({
                    currentCard: card,
                    timer: 60,
                    roundActive: true,
                    roundStartTime: firebase.database.ServerValue.TIMESTAMP
                });

                // Reset skip limit for the round
                this.game.skips = 1;

                // Display card immediately
                this.game.displayCard(card);

                // Display card immediately
                this.game.displayCard(card);
            }

            async nextCard(scored) {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;

                // Log the current word for this player's session summary
                if (this.game.currentCard) {
                    this.game.wordLog.push({
                        word: this.game.currentCard.word,
                        type: this.game.currentCard.type,
                        level: this.game.currentCard.level,
                        status: scored ? 'correct' : 'skipped'
                    });

                    if (scored) {
                        const currentScore = this.players[this.playerId]?.score || 0;
                        await this.roomRef.child(`players/${this.playerId}/score`).set(currentScore + 1);
                    }
                    await this.addSessionPlayed(this.game.currentCard.id);
                }

                // Get next card
                const pool = this.game.getPool(this.gameState.level);
                if (pool.length === 0) {
                    await this.endRound(false);
                    return;
                }

                const card = pool[Math.floor(Math.random() * pool.length)];
                this.game.currentCard = card;
                await this.addSessionPlayed(card.id);

                // Update Firebase with new card and clear buzz state
                try {
                    await this.roomRef.child('gameState').update({
                        currentCard: card,
                        lastBuzz: null
                    });
                } catch (e) {
                    console.error("Error updating next card:", e);
                }

                // Display card immediately
                this.game.displayCard(card);
            }

            async markBuzzed() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;
                if (!this.gameState.roundActive) return;

                // Clear buzz event
                await this.roomRef.child('gameState/lastBuzz').set(null);

                // Mark card as buzzed (remove from play, no score)
                if (this.game.currentCard) {
                    await this.addSessionPlayed(this.game.currentCard.id);
                }

                // Get next card
                await this.nextCard(false);
            }

            async skipCard() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;

                if (this.game.skips > 0) {
                    this.game.skips--;
                    await this.nextCard(false);
                }
            }

            async buzzPlayer() {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId === this.playerId) return; // Can't buzz yourself
                if (!this.gameState.roundActive) return; // Round not active

                // Send buzz event
                await this.roomRef.child('gameState/lastBuzz').set({
                    playerId: this.playerId,
                    playerName: this.players[this.playerId]?.name || 'Unknown',
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                this.game.playObnoxiousBuzzer();
            }

            async endRound(lastCorrect) {
                if (!this.roomRef || !this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                if (currentPlayerId !== this.playerId) return;

                // Prevent multiple calls
                if (this.endingRound) return;
                this.endingRound = true;

                if (this.game.currentCard) {
                    this.game.wordLog.push({
                        word: this.game.currentCard.word,
                        type: this.game.currentCard.type,
                        level: this.game.currentCard.level,
                        status: lastCorrect ? 'correct' : 'timeout'
                    });
                }

                if (lastCorrect && this.game.currentCard) {
                    const currentScore = this.players[this.playerId]?.score || 0;
                    await this.roomRef.child(`players/${this.playerId}/score`).set(currentScore + 1);
                }

                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }

                // Move to next player
                const turnOrder = this.gameState.turnOrder || Object.keys(this.players);
                const currentIndex = this.gameState.currentTurnIndex || 0;
                const nextIndex = (currentIndex + 1) % turnOrder.length;
                const nextPlayer = turnOrder[nextIndex];

                await this.roomRef.child('gameState').update({
                    currentPlayer: nextPlayer,
                    currentCard: null,
                    roundActive: false,
                    timer: 60,
                    currentTurnIndex: nextIndex
                });

                // Reset flag after a delay
                setTimeout(() => {
                    this.endingRound = false;
                }, 1000);
            }

            async endGame() {
                if (!this.roomRef) return;
                await this.roomRef.child('gameState/status').set('finished');

                // Hide any visible turn indicators
                const turnIndicator = document.getElementById('multiplayer-turn-indicator');
                if (turnIndicator) turnIndicator.classList.add('hidden');
                const yourBadge = document.getElementById('your-team-badge');
                if (yourBadge) yourBadge.classList.add('hidden');
            }

            handleGameStateChange() {
                if (!this.gameState) return;

                // Update UI based on game state
                if (this.gameState.status === 'playing') {
                    this.game.showScreen('game');
                    // Sync level and update stack count
                    if (this.gameState.level) {
                        this.game.selectedLevel = this.gameState.level;
                        this.game.updateStackDisplay();
                    }
                    this.updateGameUI();
                } else if (this.gameState.status === 'lobby') {
                    this.game.showScreen('lobby');
                } else if (this.gameState.status === 'finished') {
                    // Game finished - show multiplayer end game screen
                    this.showMultiplayerEndGame();
                    return; // Stop processing other state updates
                }

                // Determine if it's my turn (needed for timer logic below)
                const currentPlayerId = this.gameState.currentPlayer;
                const isMyTurn = currentPlayerId === this.playerId;

                // Sync timer
                if (this.gameState.timer !== undefined) {
                    this.game.timeLeft = this.gameState.timer;
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.textContent = this.gameState.timer;
                        if (this.gameState.timer <= 10 && this.gameState.roundActive) {
                            timerEl.classList.add('pulse-timer');
                        } else {
                            timerEl.classList.remove('pulse-timer');
                        }
                    }

                    // Active player handles end of round when timer hits zero
                    if (this.gameState.timer === 0 && this.gameState.roundActive && isMyTurn) {
                        this.endRound(false);
                    }
                }

                // Sync current card
                const isTeamMode = !!this.gameState.teams;
                const myTeam = this.players[this.playerId]?.team;
                const currentPlayerTeam = this.players[currentPlayerId]?.team;
                const isOpposingTeam = isTeamMode && myTeam && currentPlayerTeam && myTeam !== currentPlayerTeam;
                const shouldSee = isMyTurn || (isTeamMode && isOpposingTeam);

                // Handle Finish Game prompt (New Conditional Leave Logic)
                if (this.gameState.promptFinish || this.gameState.forcedFinish) {
                    const modal = document.getElementById('modal-finish-game-prompt');
                    const msgEl = document.getElementById('finish-game-msg');
                    const continueBtn = document.getElementById('continue-anyway-btn');

                    if (modal) {
                        modal.classList.remove('hidden');
                        if (this.gameState.forcedFinish) {
                            if (msgEl) msgEl.textContent = "Too many players have left. The game must end to keep it fair for everyone.";
                            if (continueBtn) continueBtn.classList.add('hidden');
                        } else {
                            if (msgEl) msgEl.textContent = "A player left and the teams are now unbalanced. Would you like to finish and see the scores?";
                            if (continueBtn) continueBtn.classList.remove('hidden');
                        }
                    }
                }

                if (this.gameState.currentCard && this.gameState.roundActive) {
                    this.game.currentCard = this.gameState.currentCard;
                    if (shouldSee) {
                        this.game.displayCard(this.gameState.currentCard);
                    } else {
                        // Explicitly redact if not allowed to see
                        const wordEl = document.getElementById('word-to-guess');
                        const tabooEl = document.getElementById('taboo-words');
                        if (wordEl) wordEl.textContent = '???';
                        if (tabooEl) tabooEl.innerHTML = '<li class="text-slate-300 italic">Hidden from guesser</li>';
                    }
                } else if (!this.gameState.roundActive) {
                    // Clear card display if round not active
                    const wordEl = document.getElementById('word-to-guess');
                    const tabooEl = document.getElementById('taboo-words');
                    if (wordEl) wordEl.textContent = '...';
                    if (tabooEl) tabooEl.innerHTML = '';

                    // Hide buzzer modal if round ended
                    const modal = document.getElementById('modal-end-turn');
                    if (modal) modal.classList.add('hidden');
                }
            }

            showBuzzModal(buzzData) {
                // Show modal asking if they got it correct
                const modal = document.getElementById('modal-end-turn');
                const textEl = document.getElementById('buzz-modal-text');
                const hintEl = document.getElementById('last-word-hint');

                if (textEl) {
                    // Update: addressing player as 'you' for a more direct experience
                    textEl.innerHTML = `Did you get <span id="last-word-hint" class="font-bold text-pink-500"></span> correctly?`;
                }

                // Re-fetch hintEl as it might have been replaced by innerHTML
                const newHintEl = document.getElementById('last-word-hint');
                if (newHintEl && this.game.currentCard) {
                    newHintEl.textContent = `"${this.game.currentCard.word}"`;
                }
                if (modal) {
                    modal.classList.remove('hidden');
                }
            }

            updateGameUI() {
                if (!this.gameState) return;

                const currentPlayerId = this.gameState.currentPlayer;
                const isMyTurn = currentPlayerId === this.playerId;
                const isTeamMode = !!this.gameState.teams;
                const roundActive = this.gameState.roundActive;

                // Show/hide Leave Game button
                const leaveBtn = document.getElementById('leave-game-btn');
                if (leaveBtn) {
                    leaveBtn.classList.remove('hidden');
                }

                // Update HUD score with player's total score
                const scoreEl = document.getElementById('score-display');
                if (scoreEl && this.players[this.playerId]) {
                    scoreEl.textContent = this.players[this.playerId].score || 0;
                }

                // Persistent "Your Team" badge
                const yourTeamBadge = document.getElementById('your-team-badge');
                if (yourTeamBadge && this.players[this.playerId]) {
                    const myTeam = this.players[this.playerId].team;
                    if (myTeam && isTeamMode) {
                        yourTeamBadge.classList.remove('hidden');
                        yourTeamBadge.textContent = `Your Team: ${myTeam}`;
                        yourTeamBadge.className = `your-team-pill ${myTeam === 'A' ? 'team-a' : 'team-b'}`;
                    } else {
                        yourTeamBadge.classList.add('hidden');
                    }
                }

                // Show/hide multiplayer UI elements
                const turnIndicator = document.getElementById('multiplayer-turn-indicator');
                const roleBadge = document.getElementById('turn-role-badge');
                const startRoundBtn = document.getElementById('multiplayer-start-round');
                const waitingMsg = document.getElementById('multiplayer-waiting');
                const playerList = document.getElementById('multiplayer-player-list');
                const buzzerContainer = document.getElementById('multiplayer-buzzer-container');

                const currentPlayer = this.players[currentPlayerId];
                const currentPlayerName = currentPlayer?.name || 'Unknown';
                const activeTeam = currentPlayer?.team;

                // Apply team theme to game board
                const mainBoard = document.querySelector('main > div#screen-game');
                if (mainBoard) {
                    mainBoard.classList.remove('team-a-theme', 'team-b-theme');
                    if (isTeamMode && activeTeam) {
                        mainBoard.classList.add(activeTeam === 'A' ? 'team-a-theme' : 'team-b-theme');
                    }
                }

                if (turnIndicator) turnIndicator.classList.remove('hidden');
                if (playerList) playerList.classList.remove('hidden');

                // Apply team theme to indicator
                if (turnIndicator) {
                    turnIndicator.classList.remove('team-a', 'team-b', 'bg-slate-50', 'border-slate-200');
                    if (isTeamMode && activeTeam) {
                        turnIndicator.classList.add(activeTeam === 'A' ? 'team-a' : 'team-b');
                    } else {
                        turnIndicator.classList.add('bg-slate-50', 'border-slate-200');
                    }
                }

                const myTeam = this.players[this.playerId]?.team;
                const isSameTeam = isTeamMode && myTeam && activeTeam && myTeam === activeTeam;
                const isOpposingTeam = isTeamMode && myTeam && activeTeam && myTeam !== activeTeam;

                if (roleBadge) {
                    roleBadge.classList.remove('hidden', 'bg-pink-600', 'bg-blue-300', 'bg-slate-800', 'text-white');
                    if (isTeamMode) {
                        roleBadge.classList.remove('hidden');
                        if (isMyTurn) {
                            roleBadge.textContent = 'Describer View';
                            roleBadge.classList.add('bg-pink-600', 'text-white');
                        } else if (isSameTeam) {
                            roleBadge.textContent = 'Guesser View';
                            roleBadge.classList.add('bg-blue-300', 'text-white');
                        } else if (isOpposingTeam) {
                            roleBadge.textContent = 'Buzzer Duty';
                            roleBadge.classList.add('bg-slate-800', 'text-white');
                        }
                    } else {
                        roleBadge.classList.add('hidden');
                    }
                }

                if (isMyTurn) {
                    if (roundActive) {
                        if (startRoundBtn) startRoundBtn.classList.add('hidden');
                        if (waitingMsg) waitingMsg.classList.add('hidden');
                    } else {
                        if (startRoundBtn) startRoundBtn.classList.remove('hidden');
                        if (waitingMsg) waitingMsg.classList.add('hidden');
                    }
                    if (turnIndicator) {
                        turnIndicator.querySelector('#turn-indicator-text').textContent = isTeamMode ? `Team ${activeTeam} is up!` : 'Your Turn!';
                        turnIndicator.querySelector('#turn-indicator-subtext').textContent = roundActive ? 'Describe the word!' : 'Start your round when ready';
                    }
                } else {
                    if (startRoundBtn) startRoundBtn.classList.add('hidden');
                    if (waitingMsg) {
                        waitingMsg.classList.remove('hidden');
                        waitingMsg.querySelector('#waiting-text').textContent = roundActive ?
                            `${currentPlayerName} is describing...` :
                            `Waiting for ${currentPlayerName} to start their round...`;
                    }
                    if (turnIndicator) {
                        turnIndicator.querySelector('#turn-indicator-text').textContent = isTeamMode ? `Team ${activeTeam} is up!` : `${currentPlayerName}'s Turn`;
                        turnIndicator.querySelector('#turn-indicator-subtext').textContent = isTeamMode ?
                            `${currentPlayerName} is talking` : '';
                    }
                }

                // Show/hide buttons based on role
                const skipBtn = document.getElementById('btn-skip');
                const buzzedBtn = document.getElementById('btn-buzzed');
                const correctBtn = document.querySelector('button[onclick="game.nextCard(true)"]');

                if (isMyTurn && roundActive) {
                    // Active player during their round: show skip, buzzed, and correct buttons
                    if (skipBtn) skipBtn.classList.remove('hidden');
                    if (buzzedBtn) buzzedBtn.classList.remove('hidden');
                    if (correctBtn) correctBtn.classList.remove('hidden');
                    if (buzzerContainer) buzzerContainer.classList.add('hidden');
                } else if (!isMyTurn && roundActive) {
                    // Other players during active round
                    if (isOpposingTeam || !isTeamMode) {
                        // Opposing team or non-team mode: show buzzer, hide skip/correct/buzzed
                        if (skipBtn) skipBtn.classList.add('hidden');
                        if (buzzedBtn) buzzedBtn.classList.add('hidden');
                        if (correctBtn) correctBtn.classList.add('hidden');
                        if (buzzerContainer) buzzerContainer.classList.remove('hidden');
                    } else if (isSameTeam) {
                        // Same team (guessing): hide everything except timer
                        if (skipBtn) skipBtn.classList.add('hidden');
                        if (buzzedBtn) buzzedBtn.classList.add('hidden');
                        if (correctBtn) correctBtn.classList.add('hidden');
                        if (buzzerContainer) buzzerContainer.classList.add('hidden');
                    }
                } else {
                    // Round not active
                    if (skipBtn) skipBtn.classList.add('hidden');
                    if (buzzedBtn) buzzedBtn.classList.add('hidden');
                    if (correctBtn) correctBtn.classList.add('hidden');
                    if (buzzerContainer) buzzerContainer.classList.add('hidden');
                }

                // Sync skip button state with limit
                if (skipBtn && isMyTurn && roundActive) {
                    skipBtn.textContent = `Skip (${this.game.skips}/1)`;
                    skipBtn.disabled = this.game.skips <= 0;
                }

                // Show card only to active player and opposing team
                const cardContainer = document.getElementById('card-container');
                if (cardContainer) {
                    const shouldSee = roundActive && (isMyTurn || (isTeamMode && isOpposingTeam));
                    if (shouldSee) {
                        cardContainer.classList.remove('hidden');
                    } else {
                        cardContainer.classList.add('hidden');
                    }
                }
            }

            showMultiplayerEndGame() {
                this.game.showScreen('multiplayer-endgame');

                // Hide unbalanced/forced finish modal if it was showing
                const finishModal = document.getElementById('modal-finish-game-prompt');
                if (finishModal) finishModal.classList.add('hidden');

                // Determine winner(s)
                const playerArray = Object.entries(this.players).map(([id, data]) => ({
                    id,
                    ...data
                }));

                // Sort by score descending
                playerArray.sort((a, b) => (b.score || 0) - (a.score || 0));

                const isTeamMode = !!this.gameState.teams;
                let winners = [];
                let winnerText = "";
                let winnerSubtext = "";
                let winnerEmoji = "üèÜ";

                if (isTeamMode) {
                    // Team Based Scoring
                    const teamA = playerArray.filter(p => p.team === 'A');
                    const teamB = playerArray.filter(p => p.team === 'B');
                    const scoreA = teamA.reduce((sum, p) => sum + (p.score || 0), 0);
                    const scoreB = teamB.reduce((sum, p) => sum + (p.score || 0), 0);

                    // Update UI cards
                    const teamContainer = document.getElementById('team-scores-container');
                    if (teamContainer) teamContainer.classList.remove('hidden');

                    const scoreAEl = document.getElementById('team-a-total-pts');
                    const scoreBEl = document.getElementById('team-b-total-pts');
                    if (scoreAEl) scoreAEl.textContent = scoreA;
                    if (scoreBEl) scoreBEl.textContent = scoreB;

                    const cardA = document.getElementById('team-a-score-card');
                    const cardB = document.getElementById('team-b-score-card');
                    if (cardA) cardA.classList.remove('team-winner-glow');
                    if (cardB) cardB.classList.remove('team-winner-glow-b');

                    if (scoreA > scoreB) {
                        winnerText = "Team A Wins!";
                        winnerSubtext = `Total Team Scored ${scoreA} Points!`;
                        if (cardA) cardA.classList.add('team-winner-glow');
                        winners = teamA;
                    } else if (scoreB > scoreA) {
                        winnerText = "Team B Wins!";
                        winnerSubtext = `Total Team Scored ${scoreB} Points!`;
                        if (cardB) cardB.classList.add('team-winner-glow-b');
                        winners = teamB;
                    } else {
                        winnerText = "It's a Team Draw!";
                        winnerSubtext = `Both teams scored ${scoreA} points!`;
                        winners = playerArray;
                    }
                } else {
                    // FFA Scoring
                    const highestScore = playerArray[0]?.score || 0;
                    winners = playerArray.filter(p => p.score === highestScore);
                    const winnerNames = winners.map(w => w.name).join(' & ');

                    if (winners.length > 1) {
                        winnerText = "Draw!";
                        winnerSubtext = `${winnerNames} both scored ${highestScore} points!`;
                    } else {
                        winnerText = `${winners[0]?.name} Wins!`;
                        winnerSubtext = `A stunning performance with ${highestScore} points!`;
                    }

                    const teamContainer = document.getElementById('team-scores-container');
                    if (teamContainer) teamContainer.classList.add('hidden');
                }

                const isWinner = winners.some(w => w.id === this.playerId);
                if (!isWinner) winnerEmoji = "üëè";

                // Update winner indicator
                const emojiEl = document.getElementById('winner-emoji');
                const titleEl = document.getElementById('winner-title');
                const subtitleEl = document.getElementById('winner-subtitle');
                const indicatorEl = document.getElementById('winner-indicator');

                if (emojiEl) emojiEl.textContent = winnerEmoji;
                if (titleEl) titleEl.textContent = winnerText;
                if (subtitleEl) subtitleEl.textContent = winnerSubtext;
                if (indicatorEl) {
                    indicatorEl.classList.remove('winner-animation', 'loser-animation');
                    if (isWinner) {
                        indicatorEl.classList.add('winner-animation');
                    } else {
                        indicatorEl.classList.add('loser-animation');
                    }
                }

                // Display final scores
                const scoresListEl = document.getElementById('final-scores-list');
                if (scoresListEl) {
                    scoresListEl.innerHTML = '';
                    playerArray.forEach((player, index) => {
                        const div = document.createElement('div');
                        div.className = `flex justify-between items-center p-3 rounded-xl ${player.id === this.playerId ? 'bg-slate-50 border-2 border-slate-200' : 'bg-white'}`;

                        const teamIndicator = isTeamMode ?
                            `<span class="text-[9px] font-black uppercase px-2 py-0.5 rounded-full ${player.team === 'A' ? 'team-a' : 'team-b'} ml-2">Team ${player.team}</span>` : '';

                        div.innerHTML = `
                            <div class="flex items-center">
                                <span class="text-xs font-black text-slate-400 mr-3">${index + 1}</span>
                                <span class="font-bold text-slate-800">${player.name}${player.id === this.playerId ? ' (You)' : ''}</span>
                                ${teamIndicator}
                            </div>
                            <span class="font-black text-slate-800">${player.score || 0}</span>
                        `;
                        scoresListEl.appendChild(div);
                    });
                }

                // Display my words
                const myWordsListEl = document.getElementById('my-words-list');
                if (myWordsListEl) {
                    myWordsListEl.innerHTML = '';
                    if (this.game.wordLog.length === 0) {
                        myWordsListEl.innerHTML = '<p class="text-xs text-slate-400 italic">You didn\'t describe any words this game.</p>';
                    } else {
                        this.game.wordLog.forEach(item => {
                            const div = document.createElement('div');
                            div.className = "flex justify-between items-center p-3 border-b border-slate-50 last:border-0";
                            const url = this.game.getRefUrl(item.word, item.type);
                            const statusColors = { correct: 'bg-green-100 text-green-700', skipped: 'bg-yellow-100 text-yellow-700', timeout: 'bg-red-100 text-red-700' };
                            const statusLabels = { correct: '‚úì', skipped: 'Skip', timeout: 'Time' };
                            div.innerHTML = `
                                <div class="flex flex-col">
                                    <a href="${url}" target="_blank" class="word-link font-bold text-slate-700">
                                        ${item.word} <span class="text-[8px] opacity-30">‚Üó</span>
                                    </a>
                                    <span class="text-[9px] text-slate-400 uppercase font-bold">${item.level}</span>
                                </div>
                                <span class="text-[9px] font-black uppercase px-2 py-1 rounded-md ${statusColors[item.status]}">${statusLabels[item.status]}</span>
                            `;
                            myWordsListEl.appendChild(div);
                        });
                    }
                }
            }

            async validateRoomState() {
                if (!this.isHost || !this.gameState || this.gameState.status !== 'playing') return;

                const initialCount = this.gameState.initialPlayerCount || 2;
                const turnOrder = this.gameState.turnOrder || [];
                const currentPlayers = Object.keys(this.players);

                // 1. Sync Turn Order: Remove any players who are no longer in the room
                const newTurnOrder = turnOrder.filter(id => this.players[id]);

                if (newTurnOrder.length !== turnOrder.length) {
                    console.log("Syncing turn order after departure...");
                    await this.roomRef.child('gameState/turnOrder').set(newTurnOrder);

                    // If the active player is gone, skip their turn
                    if (!this.players[this.gameState.currentPlayer]) {
                        console.log("Current player left, skipping ghost turn...");
                        await this.forceSkipGhostTurn(newTurnOrder);
                    }
                }

                // 2. Check Balance Thresholds (1vN)
                const playerCount = currentPlayers.length;
                let shouldFinish = false;

                if (initialCount === 4 && playerCount === 3) {
                    // Start 4 -> 3 left (2v1) -> Mandatory end
                    shouldFinish = true;
                } else if (initialCount >= 5) {
                    const teamA = currentPlayers.filter(id => this.players[id].team === 'A');
                    const teamB = currentPlayers.filter(id => this.players[id].team === 'B');

                    if (teamA.length <= 1 || teamB.length <= 1) {
                        shouldFinish = true;
                    }
                } else if (initialCount < 4 && playerCount < 2) {
                    // FFA mode needs at least 2
                    shouldFinish = true;
                }

                if (shouldFinish && !this.gameState.forcedFinish && !this.gameState.promptFinish) {
                    console.log("Teams unbalanced, forcing game end.");
                    await this.roomRef.child('gameState/forcedFinish').set(true);
                }
            }

            // Keep this for when someone explicitly leaves while current player
            async handlePlayerDeparture(removedPlayerId) {
                // Logic mostly moved to validateRoomState for robustness
                if (this.isHost) await this.validateRoomState();
            }

            async forceSkipGhostTurn(newTurnOrder) {
                if (newTurnOrder.length === 0) {
                    await this.endGame();
                    return;
                }
                const currentIndex = this.gameState.currentTurnIndex || 0;
                const nextIndex = currentIndex % newTurnOrder.length;
                const nextPlayer = newTurnOrder[nextIndex];

                await this.roomRef.child('gameState').update({
                    currentPlayer: nextPlayer,
                    currentCard: null,
                    roundActive: false,
                    timer: 60,
                    currentTurnIndex: nextIndex
                });
            }

            async leaveRoom() {
                try {
                    if (this.roomRef && this.playerId) {
                        // Just remove the individual player node
                        await this.roomRef.child(`players/${this.playerId}`).remove();
                    }
                } catch (error) {
                    console.error('Error leaving room:', error);
                } finally {
                    this.cleanup();
                    // Using location.reload() to guarantee full fresh state and main menu return
                    location.reload();
                }
            }

            cleanup() {
                if (this.roomRef) {
                    this.roomRef.off();
                }
                this.roomRef = null;
                this.roomCode = null;
                this.isHost = false;
                this.players = {};
                this.gameState = null;
                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }
            }

            copyRoomCode() {
                if (this.roomCode) {
                    navigator.clipboard.writeText(this.roomCode).then(() => {
                        const btn = document.getElementById('btn-copy-code');
                        if (btn) {
                            const originalText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = originalText;
                            }, 2000);
                        }
                    });
                }
            }
        }

        class TabooPro {
            constructor() {
                this.db = [];
                this.playedIds = new Set();
                this.selectedLevel = null;
                this.score = 0;
                this.roundScore = 0;
                this.roundNumber = 1;
                this.roundHistory = [];
                this.wordLog = [];

                this.timeLeft = 60;
                this.skips = 1;
                this.timer = null;
                this.currentCard = null;
                this.audio = null;
                this.levels = ['A1', 'A2', 'B1', 'B2'];

                this.multiplayerMode = false;
                this.multiplayer = new MultiplayerManager(this);

                this.fetchData();
            }

            async fetchData() {
                try {
                    const response = await fetch(REMOTE_URL + '?t=' + Date.now());
                    const text = await response.text();
                    this.loadData(text);
                } catch (e) {
                    const el = document.getElementById('total-card-count');
                    if (el) el.textContent = 'Error loading list';
                }
            }

            loadData(csvText) {
                const lines = csvText.trim().split('\n');
                const results = [];
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 8) continue;
                    const word = cols[0].trim();
                    const level = cols[1].trim();
                    results.push({
                        id: word + '|' + level,
                        word,
                        level: level,
                        type: cols[2].trim(),
                        taboo: [cols[3], cols[4], cols[5], cols[6], cols[7]].map(s => s.trim())
                    });
                }
                this.db = results;
                const stored = [];
                try {
                    const raw = localStorage.getItem('taboo_played');
                    if (raw) stored.push(...JSON.parse(raw));
                } catch (_) { }
                this.playedIds = new Set(stored);
                this.updateStartUI();
            }

            getPool(level) {
                if (!level || !this.db.length) return [];
                const maxIdx = this.levels.indexOf(level);
                const playedSource = this.multiplayerMode ? this.multiplayer.sessionPlayedIds : this.playedIds;
                return this.db.filter(c => this.levels.indexOf(c.level) <= maxIdx && !playedSource.has(c.id));
            }

            addPlayed(id) {
                if (!id) return;
                if (this.multiplayerMode) return; // Session history is handled in Firebase
                this.playedIds.add(id);
                try {
                    localStorage.setItem('taboo_played', JSON.stringify([...this.playedIds]));
                } catch (_) { }
            }

            resetAllCards() {
                this.playedIds.clear();
                try { localStorage.removeItem('taboo_played'); } catch (_) { }
                this.updateStartUI();
            }

            updateStartUI() {
                const el = document.getElementById('total-card-count');
                if (!el) return;

                const startBtn = document.getElementById('btn-start-round');
                const mainText = document.getElementById('start-btn-main');
                const subText = document.getElementById('start-btn-sub');

                if (!this.selectedLevel) {
                    el.textContent = `${this.db.length} cards total ¬∑ Select a level`;
                    if (mainText) mainText.textContent = 'Select a Level';
                    if (subText) subText.classList.add('hidden');
                    return;
                }

                const pool = this.getPool(this.selectedLevel);
                el.textContent = `${pool.length} cards in stack`;

                if (!startBtn) return;

                if (pool.length === 0) {
                    startBtn.disabled = true;
                    startBtn.className = "btn-3d flex-1 bg-slate-200 text-slate-400 py-3 rounded-2xl font-black flex flex-col items-center justify-center leading-tight";
                    if (mainText) mainText.textContent = 'No cards left';
                    if (subText) {
                        subText.textContent = 'Reset to play';
                        subText.classList.remove('hidden');
                    }
                } else {
                    startBtn.disabled = false;
                    startBtn.className = "btn-3d flex-1 bg-pink-500 text-white py-3 rounded-2xl font-black flex flex-col items-center justify-center leading-tight";
                    if (mainText) mainText.textContent = 'Start Round';
                    if (subText) {
                        subText.textContent = `${pool.length} IN STACK`;
                        subText.classList.remove('hidden');
                    }
                }
            }

            updateStackDisplay() {
                const pool = this.getPool(this.selectedLevel);
                const el = document.getElementById('stack-display');
                if (el) el.textContent = pool.length;
            }

            initAudio() {
                if (!this.audio) this.audio = new (window.AudioContext || window.webkitAudioContext)();
            }

            playObnoxiousBuzzer() {
                this.initAudio();
                document.getElementById('main-body').classList.add('buzz-flash');
                setTimeout(() => document.getElementById('main-body').classList.remove('buzz-flash'), 300);

                const duration = 1.5;
                const frequencies = [150, 165, 190];

                frequencies.forEach(freq => {
                    const osc = this.audio.createOscillator();
                    const gain = this.audio.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(freq, this.audio.currentTime);

                    gain.gain.setValueAtTime(0.08, this.audio.currentTime);
                    gain.gain.linearRampToValueAtTime(0.08, this.audio.currentTime + 1.0);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audio.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.audio.destination);
                    osc.start();
                    osc.stop(this.audio.currentTime + duration);
                });
            }

            getRefUrl(word, type) {
                const normalizedType = (type || "").trim().toLowerCase();
                const wiktionaryTypes = ['noun', 'adj', 'verb', 'adj/noun', 'noun/adj', 'nom', 'verbe', 'adjectif'];
                const isWiktionary = wiktionaryTypes.includes(normalizedType);

                if (isWiktionary) {
                    // Wiktionary needs lowercase for general words to resolve correctly
                    const lowercaseWord = word.toLowerCase().replace(/\s+/g, '_');
                    return `https://fr.wiktionary.org/wiki/${encodeURIComponent(lowercaseWord)}`;
                }

                // Wikipedia generally handles capitalized titles better
                const encodedWord = encodeURIComponent(word.replace(/\s+/g, '_'));
                return `https://fr.wikipedia.org/wiki/${encodedWord}`;
            }

            setLevel(lvl, btn) {
                this.selectedLevel = lvl;
                document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.updateStartUI();
            }

            startRound() {
                if (this.multiplayerMode) {
                    // Multiplayer rounds are started by individual players
                    return;
                }

                // Single-player logic
                const pool = this.getPool(this.selectedLevel);
                if (pool.length === 0) {
                    this.showScreen('start');
                    this.updateStartUI();
                    return;
                }
                this.initAudio();
                this.roundScore = 0;
                this.timeLeft = 60;
                this.skips = 1;
                this.updateStackDisplay();
                this.nextCard(false);
                this.showScreen('game');

                this.timer = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timer-display').textContent = this.timeLeft;
                    if (this.timeLeft <= 10) document.getElementById('timer-display').classList.add('pulse-timer');
                    if (this.timeLeft <= 0) {
                        clearInterval(this.timer);
                        this.playObnoxiousBuzzer();
                        document.getElementById('last-word-hint').textContent = `"${this.currentCard.word}"`;
                        document.getElementById('modal-end-turn').classList.remove('hidden');
                    }
                }, 1000);
            }

            nextCard(scored, skipAction = false) {
                if (this.currentCard) {
                    this.wordLog.push({
                        word: this.currentCard.word,
                        type: this.currentCard.type,
                        level: this.currentCard.level,
                        status: scored ? 'correct' : (skipAction ? 'skipped' : 'timeout')
                    });
                    this.addPlayed(this.currentCard.id);
                }

                if (scored) {
                    this.roundScore++;
                    this.score++;
                }

                const pool = this.getPool(this.selectedLevel);
                this.updateStackDisplay();

                if (pool.length === 0) {
                    this.finishRound(false, true);
                    return;
                }

                this.currentCard = pool[Math.floor(Math.random() * pool.length)];
                document.getElementById('word-to-guess').textContent = this.currentCard.word;
                document.getElementById('card-level-tag').textContent = `Level ${this.currentCard.level}`;
                const list = document.getElementById('taboo-words');
                list.innerHTML = '';
                this.currentCard.taboo.forEach(t => {
                    const li = document.createElement('li');
                    li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                    li.textContent = t;
                    list.appendChild(li);
                });

                document.getElementById('score-display').textContent = this.score;
                document.getElementById('btn-skip').textContent = `Skip (${this.skips}/1)`;
                document.getElementById('btn-skip').disabled = this.skips <= 0;
            }

            skipCard() {
                if (this.skips > 0) {
                    this.skips--;
                    this.nextCard(false, true);
                }
            }

            async finishRound(lastCorrect, fromExhaust = false) {
                if (this.multiplayerMode) {
                    await this.multiplayer.endRound(lastCorrect);
                    return;
                }

                // Single-player logic
                if (this.currentCard) {
                    const lastLogIdx = this.wordLog.length - 1;
                    if (lastLogIdx >= 0 && this.wordLog[lastLogIdx].word === this.currentCard.word) {
                        this.wordLog[lastLogIdx].status = lastCorrect ? 'correct' : 'timeout';
                    } else {
                        this.wordLog.push({
                            word: this.currentCard.word,
                            type: this.currentCard.type,
                            level: this.currentCard.level,
                            status: lastCorrect ? 'correct' : 'timeout'
                        });
                    }
                    if (!fromExhaust) this.addPlayed(this.currentCard.id);
                }

                if (lastCorrect) {
                    this.roundScore++;
                    this.score++;
                }

                clearInterval(this.timer);
                this.roundHistory.push({ round: this.roundNumber, score: this.roundScore });

                document.getElementById('round-score-val').textContent = this.roundScore;
                document.getElementById('summary-title').textContent = `Round ${this.roundNumber} Done!`;
                this.roundNumber++;
                this.currentCard = null;
                this.showScreen('summary');
            }

            continueAnyway() {
                const modal = document.getElementById('modal-finish-game-prompt');
                if (modal) modal.classList.add('hidden');

                // Clear the flag in Firebase so other players don't see it anymore
                if (this.multiplayerMode && this.multiplayer.isHost) {
                    this.multiplayer.roomRef.child('gameState/promptFinish').remove();
                }
            }

            showEndGame() {
                document.getElementById('total-final-score').textContent = this.score;
                document.getElementById('total-rounds-count').textContent = this.roundHistory.length;
                const histList = document.getElementById('round-history-list');
                histList.innerHTML = '';
                this.roundHistory.forEach(h => {
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center bg-slate-50 p-3 rounded-xl";
                    div.innerHTML = `
                        <span class="text-xs font-bold text-slate-500 uppercase">Round ${h.round}</span>
                        <span class="font-black text-slate-800">${h.score} pts</span>
                    `;
                    histList.appendChild(div);
                });
                this.showScreen('endgame');
            }

            showWordReview() {
                document.getElementById('btn-show-review').classList.add('hidden');
                const reviewSection = document.getElementById('review-section');
                reviewSection.classList.remove('hidden');
                const list = document.getElementById('word-review-list');
                list.innerHTML = '';
                if (this.wordLog.length === 0) {
                    list.innerHTML = `<p class="text-xs text-slate-400 italic">No words played this session.</p>`;
                    return;
                }
                this.wordLog.forEach(item => {
                    const statusColors = { correct: 'bg-green-100 text-green-700', skipped: 'bg-yellow-100 text-yellow-700', timeout: 'bg-red-100 text-red-700' };
                    const statusLabels = { correct: 'Correct', skipped: 'Skipped', timeout: 'Buzzed' };
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center p-3 border-b border-slate-50 last:border-0";
                    const url = this.getRefUrl(item.word, item.type);
                    div.innerHTML = `
                        <div class="flex flex-col">
                            <a href="${url}" target="_blank" class="word-link font-black text-slate-700">
                                ${item.word} <span class="text-[8px] opacity-30">‚Üó</span>
                            </a>
                            <span class="text-[9px] text-slate-400 uppercase font-bold">${item.level} ‚Ä¢ ${item.type || 'N/A'}</span>
                        </div>
                        <span class="text-[9px] font-black uppercase px-2 py-1 rounded-md ${statusColors[item.status]}">${statusLabels[item.status]}</span>
                    `;
                    list.appendChild(div);
                });
            }

            showScreen(id) {
                const screens = ['start', 'game', 'summary', 'endgame', 'multiplayer-options', 'join-room', 'lobby', 'multiplayer-endgame'];
                screens.forEach(s => {
                    const el = document.getElementById('screen-' + s);
                    if (el) el.classList.add('hidden');
                });
                const targetEl = document.getElementById('screen-' + id);
                if (targetEl) targetEl.classList.remove('hidden');

                const hud = document.getElementById('game-hud');
                const leaveBtn = document.getElementById('leave-game-btn');
                const leaveSep = document.getElementById('leave-separator');

                if (hud) {
                    hud.style.opacity = (id === 'game') ? '1' : '0';
                    hud.style.pointerEvents = (id === 'game') ? 'auto' : 'none';
                }

                // Show/hide leave button and separator based on mode and screen
                if (leaveBtn && leaveSep) {
                    if (this.multiplayerMode && id === 'game') {
                        leaveBtn.classList.remove('hidden');
                        leaveSep.classList.remove('hidden');
                    } else {
                        leaveBtn.classList.add('hidden');
                        leaveSep.classList.add('hidden');
                    }
                }
            }

            // Multiplayer methods
            showMultiplayerOptions() {
                this.showScreen('multiplayer-options');
            }

            showJoinRoom() {
                this.showScreen('join-room');
            }

            async createRoom() {
                const nameInput = document.getElementById('input-host-name');
                const hostName = nameInput ? nameInput.value.trim() : null;
                const code = await this.multiplayer.createRoom(hostName);
                if (code) {
                    document.getElementById('lobby-room-code').textContent = code;
                    this.showScreen('lobby');
                } else {
                    alert('Failed to create room. Please check Firebase configuration.');
                }
            }

            async joinRoom() {
                const codeInput = document.getElementById('input-room-code');
                const nameInput = document.getElementById('input-player-name');
                const code = codeInput.value.trim().toUpperCase();
                const name = nameInput.value.trim();

                if (!code || code.length !== 4) {
                    alert('Please enter a valid 4-character room code.');
                    return;
                }

                if (!name || name.length === 0) {
                    alert('Please enter your name.');
                    return;
                }

                const success = await this.multiplayer.joinRoom(code, name);
                if (success) {
                    this.multiplayerMode = true;
                    document.getElementById('lobby-room-code').textContent = code;
                    this.showScreen('lobby');
                }
            }

            async leaveRoom() {
                await this.multiplayer.leaveRoom();
            }

            setMultiplayerLevel(level, btn) {
                this.selectedLevel = level;
                document.querySelectorAll('#screen-lobby .level-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const startBtn = document.getElementById('btn-start-game');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.className = "btn-3d w-full bg-pink-500 text-white py-4 rounded-2xl text-xl font-black";
                    startBtn.textContent = `Start Game (Level ${level})`;
                }
            }

            async startMultiplayerGame() {
                if (!this.selectedLevel) {
                    alert('Please select a level first.');
                    return;
                }
                this.multiplayerMode = true;
                await this.multiplayer.startGame(this.selectedLevel);
            }

            async startMultiplayerRound() {
                await this.multiplayer.startRound();
            }

            displayCard(card) {
                if (!card) return;
                document.getElementById('word-to-guess').textContent = card.word;
                document.getElementById('card-level-tag').textContent = `Level ${card.level}`;
                const list = document.getElementById('taboo-words');
                if (list) {
                    list.innerHTML = '';
                    card.taboo.forEach(t => {
                        const li = document.createElement('li');
                        li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                        li.textContent = t;
                        list.appendChild(li);
                    });
                }
            }

            async markBuzzed() {
                if (this.multiplayerMode) {
                    await this.multiplayer.markBuzzed();
                }
            }

            async nextCard(scored) {
                if (this.multiplayerMode) {
                    await this.multiplayer.nextCard(scored);
                } else {
                    // Original single-player logic
                    if (this.currentCard) {
                        this.wordLog.push({
                            word: this.currentCard.word,
                            type: this.currentCard.type,
                            level: this.currentCard.level,
                            status: scored ? 'correct' : 'timeout'
                        });
                        this.addPlayed(this.currentCard.id);
                    }

                    if (scored) {
                        this.roundScore++;
                        this.score++;
                    }

                    const pool = this.getPool(this.selectedLevel);
                    this.updateStackDisplay();

                    if (pool.length === 0) {
                        this.finishRound(false, true);
                        return;
                    }

                    this.currentCard = pool[Math.floor(Math.random() * pool.length)];
                    document.getElementById('word-to-guess').textContent = this.currentCard.word;
                    document.getElementById('card-level-tag').textContent = `Level ${this.currentCard.level}`;
                    const list = document.getElementById('taboo-words');
                    list.innerHTML = '';
                    this.currentCard.taboo.forEach(t => {
                        const li = document.createElement('li');
                        li.className = "bg-slate-50 py-3 rounded-xl font-bold text-slate-600 border border-slate-100";
                        li.textContent = t;
                        list.appendChild(li);
                    });

                    document.getElementById('score-display').textContent = this.score;
                    document.getElementById('btn-skip').textContent = `Skip (${this.skips}/1)`;
                    document.getElementById('btn-skip').disabled = this.skips <= 0;
                }
            }

            async skipCard() {
                if (this.multiplayerMode) {
                    await this.multiplayer.skipCard();
                } else {
                    // Original single-player logic
                    if (this.skips > 0) {
                        this.skips--;
                        this.nextCard(false, true);
                    }
                }
            }

            copyRoomCode() {
                this.multiplayer.copyRoomCode();
            }

            handleBuzzer() {
                if (this.multiplayerMode && this.multiplayer.gameState) {
                    const currentPlayerId = this.multiplayer.gameState.currentPlayer;
                    const isMyTurn = currentPlayerId === this.multiplayer.playerId;
                    if (!isMyTurn && this.multiplayer.gameState.roundActive) {
                        // Buzzing another player
                        this.multiplayer.buzzPlayer();
                    } else {
                        // Just play sound if it's your turn or round not active
                        this.playObnoxiousBuzzer();
                    }
                } else {
                    // Single player mode
                    this.playObnoxiousBuzzer();
                }
            }

            showLeaveGameModal() {
                if (!this.multiplayerMode) return;

                const modal = document.getElementById('modal-leave-game');
                const leaveBtn = modal.querySelector('button[onclick*="confirmLeaveAction(\'leave\')"]');
                const endForAllBtn = document.getElementById('end-for-all-btn');
                const initialCount = this.multiplayer.gameState?.initialPlayerCount || 4;

                // Rule 1: 2-Player Match (initialCount === 2) -> No individual Leave
                if (initialCount === 2) {
                    if (leaveBtn) leaveBtn.classList.add('hidden');
                    if (endForAllBtn) {
                        endForAllBtn.classList.remove('hidden');
                        endForAllBtn.textContent = 'End Game for All';
                    }
                } else {
                    if (leaveBtn) leaveBtn.classList.remove('hidden');
                    // Only show "End for All Players" option if user is the host
                    if (endForAllBtn) {
                        if (this.multiplayer.isHost) {
                            endForAllBtn.classList.remove('hidden');
                            endForAllBtn.textContent = 'End for All Players';
                        } else {
                            endForAllBtn.classList.add('hidden');
                        }
                    }
                }

                if (modal) modal.classList.remove('hidden');
            }

            async executeFinishGame() {
                this.hideFinishPrompt();
                await this.multiplayer.endGame();
            }

            hideFinishPrompt() {
                const modal = document.getElementById('modal-finish-game-prompt');
                if (modal) modal.classList.add('hidden');
                // Also clear the flag in DB so it doesn't pop up again for anyone else immediately
                if (this.multiplayer.isHost && this.multiplayer.roomRef) {
                    this.multiplayer.roomRef.child('gameState/promptFinish').set(null);
                }
            }

            hideLeaveGameModal() {
                const modal = document.getElementById('modal-leave-game');
                if (modal) modal.classList.add('hidden');
            }

            confirmLeaveAction(action) {
                // Store the action to execute later
                this.pendingLeaveAction = action;

                // Hide first modal
                this.hideLeaveGameModal();

                // Show confirmation modal with appropriate text
                const confirmModal = document.getElementById('modal-confirm-leave');
                const confirmText = document.getElementById('confirm-leave-text');

                if (action === 'endAll') {
                    confirmText.textContent = 'This will end the game for all players. Are you sure?';
                } else {
                    confirmText.textContent = 'You will leave the game. Are you sure?';
                }

                if (confirmModal) confirmModal.classList.remove('hidden');
            }

            cancelLeaveConfirm() {
                const modal = document.getElementById('modal-confirm-leave');
                if (modal) modal.classList.add('hidden');
                this.pendingLeaveAction = null;
            }

            async executeLeaveAction() {
                const modal = document.getElementById('modal-confirm-leave');
                if (modal) modal.classList.add('hidden');

                if (this.pendingLeaveAction === 'endAll') {
                    // End game for all players - set status to finished
                    // Don't leave the room, let players see the end game screen
                    await this.multiplayer.endGame();
                } else {
                    // Just leave the room
                    await this.multiplayer.leaveRoom();
                }

                this.pendingLeaveAction = null;
            }

            async handleBuzzResponse(correct) {
                const modal = document.getElementById('modal-end-turn');
                if (modal) modal.classList.add('hidden');

                if (this.multiplayerMode) {
                    // Clear buzz event
                    if (this.multiplayer.roomRef) {
                        await this.multiplayer.roomRef.child('gameState/lastBuzz').set(null);
                    }
                    // If correct, mark as scored, otherwise mark as buzzed
                    if (correct) {
                        await this.multiplayer.nextCard(true);
                    } else {
                        await this.multiplayer.markBuzzed();
                    }
                    // Stay on game screen, just clear modal
                    this.showScreen('game');
                } else {
                    // Single player mode
                    await this.finishRound(correct);
                }
            }
        }

        let game;
        window.onload = () => { game = new TabooPro(); };
    </script>
</body>

</html>